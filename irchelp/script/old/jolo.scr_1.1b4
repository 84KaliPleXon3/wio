###########################################
#                 JoloPak                 #
# by Joseph Lo (jolo@deckard.mc.duke.edu) #
###########################################

assign jp_version 1.1b4
assign jp_date (2/13/97 3:16 pm)
alias version {
	//version 
	echo *** Running JoloPak $jp_version $jp_date
}

# Get the latest version at  http://www.irchelp.org/irchelp/script/

# This script is largely based on the widely available SuperPak, which
# is a very complete but long (4500 lines!) non-war script pack. This is
# only 1/4 the size after I trimmed the lard and added many convenient
# aliases and some kewl new features courtesy of fellow #IRChelp ops.
# If you have unanswered questions, ask on EFnet's #IRChelp or visit
# us on the WWW at  http://www.irchelp.org/

# INSTALLATION:
#   Save the file as .ircrc in your shell account home directory.
#   Personalize "myversion", "myhome" and "SET USER_INFORMATION" commands below.
#   Launch ircII as usual (usually type "irc") -- that's it!
# ADVANCED USERS:
#   Customize your control key bindings (search forward for "BIND").
#   Play with the SETs (to learn their meanings, "/help set") and ALIASes.
#   Put your version in the CTCP flood protection function (search for "SunOS").

## Change the following to whatever version you are running: launch IRC without
## any scripts by "irc -q", then /ctcp your_nick version, copy everything after
## "CTCP VERSION reply from your_nick:" and paste it below after "myversion".
## Likewise put your home directory after "myhome" below.
assign myversion ircII 2.9_roof SunOS 5.5
assign myhome /home/jyl

# Personalize the following to suit you, don't use any line breaks.
SET USER_INFORMATION My name is John Doe. I like wet puppies, good food, and http://www.irchelp.org/

## If you didn't do a standard installation of ircII, you will have to change
## the following 2 lines to suit your setup.
eval SET LOAD_PATH .:$myhome:/usr/local/lib/irc/script
SET HELP_PATH /usr/local/lib/irc/help
## If you don't have /help, uncomment this to use the EFnet help bot "ai-"
#SET HELP_SERVICE ai-
eval SET HISTORY_FILE $myhome/history
eval SET LOGFILE $myhome/irclog

######################################################
#####                A L I A S E S              ######
######################################################

ALIAS IDLE {WHOIS $0 $0}
ALIAS DNS EXEC nslookup $0
ALIAS P CTCP $0 PING $time()
ALIAS PART if ([$0]) {//part $0-} {//part $C}
ALIAS RELOAD LOAD .ircrc
ALIAS SLAP /me slaps a large trout around a bit with $0
ALIAS T if (index(#*& $[1]0) > -1) { ${K}${K}topic $*} { ${K}${K}topic $C $*}
ALIAS V //CTCP $0 VERSION
ALIAS W //WHOIS $0
ALIAS H+ SET HOLD_MODE ON
ALIAS H- SET HOLD_MODE OFF
ALIAS I+ SET INPUT_ALIASES ON
ALIAS I- SET INPUT_ALIASES OFF

##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
## From here on out, you don't need to change anything unless you're an
## advanced user who wants to customize things or to learn more about scripting.
## This section affects how ircII behaves, check /help before changing anything.
##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

## Most of these are the same as ircII's default settings, but I list them
## so you can learn more about them, such as: /help set always_split_biggest

SET ALWAYS_SPLIT_BIGGEST ON
SET AUTO_WHOWAS ON
SET BEEP ON
SET BEEP_MAX 2
SET BEEP_ON_MSG MSG
SET BEEP_WHEN_AWAY 1
SET BOLD_VIDEO ON
SET CHANNEL_NAME_WIDTH 0
eval SET CLIENT_INFORMATION Running JoloPak $jp_version
SET CLOCK OFF
SET CLOCK_24HOUR ON
SET CLOCK_ALARM OFF
SET CMDCHARS /
SET COMMAND_MODE OFF
SET CONTINUED_LINE    
SET DCC_BLOCK_SIZE 2048
SET DEBUG 0
SET DISPLAY OFF
SET DISPLAY_ANSI OFF
SET EIGHT_BIT_CHARACTERS ON
SET EXEC_PROTECTION ON
SET FLOOD_AFTER 5
SET FLOOD_RATE 3
SET FLOOD_USERS 3
SET FLOOD_WARNING ON
SET FULL_STATUS_LINE ON
SET HELP_PAGER ON
SET HELP_PROMPT ON
SET HELP_WINDOW OFF
SET HIDE_PRIVATE_CHANNELS OFF
SET HIGHLIGHT_CHAR BOLD
SET HISTORY 150
SET HOLD_MODE OFF
SET HOLD_MODE_MAX 0
SET INDENT ON
SET INPUT_ALIASES OFF
SET INPUT_PROMPT $T> 
SET INPUT_PROTECTION OFF
SET INSERT_MODE ON
SET INVERSE_VIDEO ON
SET LASTLOG 1000
SET LASTLOG_LEVEL DCC,ALL
SET LOG OFF
SET MAIL 0
SET MAX_RECURSIONS 10
# SET MINIMUM_SERVERS
# SET MINIMUM_USERS
SET MODE_STRIPPER ON
SET NOTIFY_HANDLERS NOISY
SET NOTIFY_LEVEL ALL
SET NOTIFY_ON_TERMINATION OFF
SET NOVICE OFF
SET NO_CTCP_FLOOD ON
SET NUM_OF_WHOWAS 1
SET PAD_CHAR -
SET PAUSE_AFTER_MOTD ON
SET SCROLL ON
SET SCROLL_LINES 1
SET SEND_IGNORE_MSG OFF
# SET SHELL_FLAGS
SET SHELL_LIMIT 0
SET SHOW_AWAY_ONCE ON
SET SHOW_CHANNEL_NAMES ON
SET SHOW_END_OF_MSGS OFF
SET SHOW_NUMERICS OFF
SET SHOW_STATUS_ALL OFF
SET SHOW_WHO_HOPCOUNT ON
SET STATUS_AWAY  (Away)
SET STATUS_CHANNEL  %C
SET STATUS_CHANOP @
SET STATUS_CLOCK  %T
SET STATUS_DQUERY DCC Querying %D
SET STATUS_FORMAT %T [%R] %*%@%N%#%S%H%B%Q%A%C%+%I%O%M%F %U %W %C 
SET STATUS_HOLD  Held:
SET STATUS_HOLD_LINES  %B
SET STATUS_INSERT
SET STATUS_MAIL  [Mail: %M]
SET STATUS_MODE  (+%+)
SET STATUS_NOTIFY  (W: %F)
SET STATUS_NO_REPEAT OFF
SET STATUS_OPER *
SET STATUS_OVERWRITE  (Overwrite)
SET STATUS_QUERY  (Query: %Q)
SET STATUS_SERVER  (%S)
SET STATUS_UMODE  (+%#)
SET STATUS_USER *
SET STATUS_USER1
SET STATUS_USER2
SET STATUS_USER3
SET STATUS_USER4
SET STATUS_USER5
SET STATUS_USER6
SET STATUS_USER7
SET STATUS_USER8
SET STATUS_USER9
SET STATUS_WINDOW  ^^^^^^^^^
SET SUPPRESS_SERVER_MOTD ON
SET TAB_MAX 1
# SET TRANSLATION
SET UNDERLINE_VIDEO ON
SET USER_WALLOPS ON
SET USE_OLD_MSG OFF
SET VERBOSE_CTCP ON
SET WARN_OF_IGNORES ON
SET XTERM_OPTIONS

BIND META1-O META2
BIND META1-[ META2
BIND META2-A BACKWARD_HISTORY
BIND META2-B FORWARD_HISTORY
BIND META2-C FORWARD_CHARACTER
BIND META2-D BACKWARD_CHARACTER
BIND ^B SELF_INSERT
BIND ^N SWITCH_CHANNELS
BIND ^P SCROLL_BACKWARD
BIND ^W NEXT_WINDOW
BIND ^V SELF_INSERT
BIND ^Z STOP_IRC
BIND ^_ SELF_INSERT


## The following loads various scripts and functions.  If you don't have them,
## it should simply say "file not found" and move on - no harm done.

LOAD tabkey
LOAD killpath

## Following line is necessary otherwise will cut off flooding messages
## without warning to you (see /help set flood_warning)
ON ^FLOOD *

ON #^MSG 0 * ECHO *$0* $1-
ON ^NOTICE * ECHO -$0\- $1-
ON ^NOTIFY_SIGNOFF * ECHO --- Signoff: $0
ON ^NOTIFY_SIGNON * ECHO +++ Signon: $0 $1
ON ^PUBLIC 10 * ECHO <$0> $2-
on ^public_other * echo [$1] <$0> $2-
on ^send_msg * echo -> *$0* $1-
on ^send_notice * echo -> -$0\- $1-
on ^ctcp_reply "* ERRMSG *ACTION*" :

on ^002 * comment
on ^send_action * if ([$[1]0]!=[#])
  {echo === Describe [-> $0] : $N $1-}
  {echo === Action: $N $1-}
on ^action * if ([$[1]1]!=[#])
 {echo *** Describe: $0 $2-}
 {if ([$C]!=[$1]) {echo === Action [$1] : $0 $2-}
                  {echo === Action: $0 $2-}}
## Display your nick when you talk on a channel
on ^send_public * {
	if ( [$0] == C ) { echo <$N> $1- } { echo -> <$0> $1- }
}
### /lusers        info:
alias lusers {

  ^on ^251 * {
    ^assign -nusers
    ^assign -nusersi
    ^assign -nservers
    ^assign nusers $3
    ^assign nusersi $6
    ^assign nservers $9
    @nuserst = nusers + nusersi
    echo *** There are $nuserst total users \($nusers + $nusersi invisible\) on $nservers servers
    }

  ^on ^252 * echo *** $$1 server operators online

  ^on ^255 * {
    ^assign -musers
    ^assign musers $3
    ^assign -nusersp
    ^assign -nusersp2
    @nusersp = musers * 100
    @nusersp2 = nusersp / nuserst
    echo *** This server has $musers users \(~ $nusersp2\% of total) and $6 servers connected to it
    }
  //lusers $remote_server
  wait
  ^on ^251 -*
  ^on ^252 -*
  ^on ^255 -*
}

# Ban info patch (such as from /bs)
on ^367 * if ([$4] != []) {echo *** $1 \($3: $stime($4)) $2} {echo *** $1-}

# Topic info patch
on ^333 * echo *** Topic for $1 set by $2 on $stime($3)

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*#*         FOLLOWING STUFF IS FROM BARRON'S SUPERPAK SCRIPT.          #*#*
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

#####################
#AUTO REJOIN ON KICK
#####################
# features built in 7 sec delay to make it look like a manual rejoin
# Auto-rejoin is OFF by default (many consider it very rude!)
^assign auto_rejoin ON

alias autorejoin {
if ([$0]) 
  {
  ^assign auto_rejoin $0
  if ([$auto_rejoin] == [on]) {
  ^assign auto_rejoin ON
  echo #*#* Auto-Rejoin has been set to  ON 
  } {
    ^assign auto_rejoin OFF
    echo #*#* Auto-Rejoin has been set to  OFF 
  } 
}{
echo #*#* Usage: /autorejoin on | off   to set your auto rejoin state
echo #*#*        Makes you rejoin a channel automatically if you are kicked off
echo ->>  Current Auto Rejoin Status:  $auto_rejoin 
 }
}

on -raw_irc "% KICK *" if ( ([$3] == [$N]) && ([$auto_rejoin] == [ON] ) ) { 
msg $N xtj $2 
echo Rejoining $2 in 7 secs, abort by typing: /timer -del 911
 }{}
on ^msg "% xtj *" if ( [$0] == [$N] ) { timer -refnum 911 7 join $2 }{}

################################
# Finger script III by Daemon.
################################
# finger nickname         will finger the user@host of the nickname
# finger -h nickname      will finger the @host of the nickname
# finger user@host.name   will finger the given user@host
# finger @host.name       will finger the given @host.name

alias f finger

alias finger {
	^exec -kill %finger
	if (([$0] == [-h]) && ([$1] != []))
	{
		userhost $1 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching Host finger on:  $0 -> @$4 
                  eval exec -name finger exec finger @$$4 }
				{ echo *** FINGER: no such nickname $1 }
	}
	{
	if (index(@ $0) > -1)
	{
		exec -name finger exec finger $0
	}
	{
	if ([$0])
	{
		userhost $0 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching finger on: $0 $strip(#!> $3)@$4 
                  eval exec -name finger exec finger $strip(#~> $3)@$$4 }
				{ echo *** FINGER: no such nickname $0 }
	}
	{
		echo *** Usage: finger [[-h] <nickname>][[user]@full.hostname]
		echo *** e.g. finger bob, finger -h bob, finger robert@eff.org, or finger @eff.org
	}}}
}

## Jolo's note: The following are channel protection commands which will soon be
## replaced with much more powerful stuff in a separate, non-newbie script.

## Here are some simple aliases
## Show bans on current channel
ALIAS BS MODE $C b
## Op or Deop up to 4 nicknames
ALIAS CHOP MODE $C +ooo $0 $1 $2 $3
ALIAS DEOP MODE $C -ooo $0 $1 $2 $3
## Old fashioned kick, just /k nickname [optional reason]
ALIAS K {if ([$1]) {//kick $C $0 $1-} {//kick $C $0}}
## Unban the specified nick!user@host pattern (do /bs then copy & paste)
ALIAS UB //MODE $C -b $0

########################################
#ONE STEP DEOP+TRADITIONAL BAN+KICK (/FUCK NICK [comment])
########################################
## Jolo's note: works with numeric IPs but only barely, will improve soon
alias fuck {
^assign -him
^assign him $0
^assign -fuck_comment
^assign fuck_comment $1-
userhost $him -cmd fuck2 $$0 $$3 $$4
}
alias fuck2 {
if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {fuck3 $0 $1 $2}
}
alias fuck3 {
^assign -nic
^assign -usr
^assign -mach
^assign -machine
^assign nic $0
^assign usr $strip(#~ $1)
^assign mach $2
^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
^assign machine *.$enleve($2)
//mode $C +bb *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
#//mode $C -o+bb $nic *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
if ([$fuck_comment]) {} {^assign fuck_comment $N}
//kick $C $nic ${fuck_comment}
}

######################
#TRADITIONAL BAN: /BAN NICK
######################
alias b ban

alias ban {
if ([$0]) {
^assign -him
^assign him $0
userhost $him -cmd ban2 $$0 $$3 $$4
} {mode $C +b}
}
alias ban2 {
if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {ban3 $0 $1 $2}
}
alias ban3 {
^assign -nic
^assign -usr
^assign -mach
^assign -machine
^assign nic $0
^assign usr $strip(#~ $1)
^assign mach $2
^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
^assign machine *.$enleve($2)
mode $C +b *!*$mid(0 8 $usr)*@$machine
}

############################################
#         SHOWS USERS ON A CHANNEL         #
# usage: /look    or   /count   to display #
# or : /look #channel   or /count #channel #
# who is or how many on channel            #
# by TG!cedras@rahul.net                   #
# This sucker is faster then older code :) #
############################################

alias repeat {
	@ rep.cnt = [$0]
	while ( rep.cnt > 0 )
	{
		$1-
		@rep.cnt = rep.cnt - 1
	}
	^assign -rep.cnt
}


alias look {
   @whoonc = [yes]
   @on_channel = C
   if ([$0]) 
     {
      @on_channel = [$0]
      } 
  whoon
  }

alias count {
   @on_channel = C
  if ([$0]) 
   {
    @on_channel = [$0]
    } 
  whoon
  }

alias whoon {
   ^assign -total
   ^assign -wholist
   ^assign -whonum
   @opernum = 0
   @ircopnum = 0
   @nochop = 0	
   ^on ^who "*Channel*" /comment
   ^on ^who "*End of* /comment
   ^on ^who "*" whocount $$1 $$2
   ^who $on_channel
   ^wait
   @total = [$#whonum]
   @nochop = total - opernum
   if ( whoonc == [yes] ) {show_look $wholist}
   echo #*#* ON Channel ${on_channel}
   echo #*#* [TOTAL : $total users] [$opernum Chops] [$nochop NotChops] [$ircopnum IrcOPs]
   ^on ^who -
   ^assign whoonc no
  }
alias whocount {
   if ([$1]==[G@]||[$1]==[H@]||[$1]==[G*@]||[$1]==[H*@]) {@opernum=opernum+1}
   if ([$1]==[G*]||[$1]==[H*]||[$1]==[G*@]||[$1]==[H*@]) {@ircopnum=ircopnum+1}
   ^assign -dash_fill
   @diff = 0
   ^assign -nicklength
   @chanstat = [$1]
   if ([$@chanstat]==[1]) {@nickad = [$chanstat\-\-]}
   if ([$@chanstat]==[2]) {@nickad = [$chanstat\-]}
   if ([$@chanstat]==[3]) {@nickad = [$chanstat]}
   @nick = [$0\-$nickad]
   @nicklength = [$@nick]
   @diff = 13 - nicklength
   repeat $diff @dash_fill = dash_fill ## [-]
   ^assign enclosed [$dash_fill$nick]
   @wholist = [$wholist $enclosed]
   @whonum = [$whonum $1]
  }

alias show_look {
  @wholist_size = [$#wholist]
  @wholist_counter = 0
  while (wholist_counter < wholist_size) {
    @ind_wholist =0
    ^assign -wholist_display
    while (ind_wholist < 4) {
      ^assign wholist_display $wholist_display $word($wholist_counter $wholist)
      @ind_wholist = ind_wholist + 1
      @wholist_counter = wholist_counter + 1
      }
    echo ---> $wholist_display
    }
}

############# END OF /LOOK  /COUNT  FUNCTIONS

###########################
#  IGNORING FUNCTION      #
#  BY TG!cedras@rahul.net #             
#  /ig /uig /sig /zig     #
###########################

alias shoo {
	userhost $, -cmd ^assign hostig $$3@$$4
	ignore $hostig msg
	timer 60 ignore $hostig -msg
	^assign -hostig
}

# typing ctrl-o will ignore the last person who sent you a message
BIND ^o parse_command ig2 $,

## IGNORING (/ig <nick> or <whatever>)

alias ig {
  if ([$0]) {
    ^assign -ignick
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_ig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      ^assign ignore_list $ignore_list $0
      echo #*#*#  $ignick \( $ignick \) is been ignored !
      #//^ignore $ignick all
      //^ignore $ignick all -crap
      @igflag = 0
      }
     }{
       echo *** USAGE: To ignore someone completely: /ig <nick> or <address>
	}
  }

alias do_ig {
  if ([$0]!=[<UNKNOWN>]) {add_iglist $0 $1}
  }

alias add_iglist {
  @igflag = 1

  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  ^assign ignore_list $ignore_list $igfinal
  echo #*#*#  $ignick \( $igfinal \) is been ignored !
  //^ignore $igfinal all
  }

alias ig2 {
  if ([$0]) {
    ^assign -ignick
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_ig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      ^assign ignore_list $ignore_list $0
      echo #*#*#  $ignick \( $ignick \) is been ignored !
      //^ignore $ignick msgs walls wallops invites notices notes ctcps crap
      @igflag = 0
      }
     }{
       echo *** USAGE: To ignore someones hostname completely: /ig2 <nick> or <address>
       }
  }

alias do_ig {
  if ([$0]!=[<UNKNOWN>]) {add_iglist $0 $1}
  }

alias add_iglist {
  @igflag = 1

  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*@$machine]
  ^assign ignore_list $ignore_list $igfinal
  echo #*#*#  $ignick \( $igfinal \) is been ignored !
  //^ignore $igfinal msgs walls wallops invites notices notes ctcps crap
  }


## UNIGNORING (/uig <nick> or <whatever>)

alias uig {
  if ([$0]) {
    ^assign -ignick
    ^assign -igfinal
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_nig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      @ignore_list = [$remove_word($0 $ignore_list)]
      echo #*#*#  $ignick \( $ignick \) is being removed from ignorance !
      //ignore $ignick none
      @igflag = 0
      }
    }{
      echo *** USAGE: To remove someone from ignorance list /uig <nick> or <address>
   }
 }

alias do_nig {
  if ([$0]!=[<UNKNOWN>]) {remove_iglist $0 $1}
}

alias remove_iglist {
  @igflag = 1
  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  @ignore_list = [$remove_word($igfinal $ignore_list)]
  echo #*#*#  $ignick \( $igfinal \) is being removed from ignorance !
  //ignore $igfinal none
  }

## SHOW IGNORE LIST (/sig)

alias sig echo #*#*# My_Ignorance_List:;echo ->>   $ignore_list

## ZAP IGNORE LIST (/zig)

alias zig {
  @ind=0
  while ( word($ind $ignore_list-) ) {
    //ignore $word($ind $ignore_list) none
    @ind=ind+1
  }
  ^assign -ignore_list
  echo #*#*# Ignorance list has been cleared !
  }

################# SPECIAL FUNCTIONS by Jeremy Nelson   hop!jnelson@iastate.edu
alias leftw {
    @ function_return = [$(1-$0)]
}
alias restw {
    @ function_return = [$(${[$0]+1}-)]
}
alias notw {
    if ([$0])
       {@ _pad = [ ]}
       {@ _pad = []}
    @ _words = [$1-]
    @ function_return = [$leftw($0 $1-)] ## [$_pad] ## [$restw(${[$0]+1} $1-)]
}

alias remove_word {
    @ _pattern = rmatch($0 $1-) - 1
    if (_pattern != -1)
       {@ function_return = notw($_pattern $1-)}
       {@ function_return = [$1-]}
}

################# END OF IGNORE FUNCTION

######################################
# SMART /CHAT INTERFACE              #
# BY TG!cedras@rahul.net             #
######################################
# to initiate a chat connection      #
# -> type: /chat <nickname>          #
# to close current connection and    #
# initiate another                   #
# -> type: /chat <new nickname>      #
# to connect to a chat request       #
# -> type: /chat                     #
# to close current connection and    #
# respond to a request               #
# -> type: /chat                     #
# to close a chat connection         #
# -> type: /chat                     #
#                                    #
# /autoquery on | off   to set auto  #
#                       query mode   #
######################################
## This is not really necessary, I personally prefer to do it manually by
## /dcc chat nickname then /msg =nickname blah blah (note =) (or hit tab).

########### SMART /CHAT INTERFACE

on ^ctcp "% % DCC CHAT % *" {
@chat_request = [$0]
}


alias chat {
if (![$chat_current] && ![$chat_request] && ![$0] ) {
echo #*#* No chat requests issued to you or nickname Specified
}{
  if (chat_current)
   {
    //dcc close chat $chat_current
    ^assign -chat_current
    if ([$auto_query] == [on]) {//query}
    }
  if ([$0])
   {
   //dcc chat $0
   @chat_current = [$0]
   if ([$auto_query] == [on]) {//query =$chat_current}
   ^assign -chat_request
    } {
      if (chat_request)
       {
       //dcc chat $chat_request
       @chat_current = chat_request
       if ([$auto_query] == [on]) {//query =$chat_current}
       ^assign -chat_request
        }
       }
    }
}

############### AUTO_QUERY SWITCH

# AUTOQUERY IS ON BY DEFAULT, CHANGE THE NEXT LINE IF YOU DONT
# WANT IT THAT WAY
^assign auto_query ON
####################


alias autoquery {
if ([$0]) {
  ^assign auto_query $0
  if ([$auto_query] == [on]) {
  ^assign auto_query ON
  echo #*#* Auto-Query has been set to  ON 
  } {
    ^assign auto_query OFF
    echo #*#* Auto-Query has been set to  OFF 
  } 
}{
echo #*#* Usage: /autoquery on | off   to set your auto-query mode
echo #*#*        Puts you automatically in query mode on a dcc chat if set to ON
echo ->>  Current Auto Query Status:  $auto_query 
 }
}

################## END OF /CHAT  FUNCTION

#########################################
#         IRC Answering Machine         #
#        by  TG!cedras@rahul.net        #       
#########################################
# This Script records all incoming      #
# Messages and Notices to you whether   #
# You are present or away               #
# *hysterical laughs*   Yes ! :-)       #
# We have indeed gone mad :)            #
#########################################
# How to Use:                           #
# /record     tells your machine status #
# /record ON  to set machine ON         #
# /record OFF to set machine OFF        #
# /play       to play back your msgs    #
# /erase      to erase messages         #
# /playmsg    to play back message file #
# /savemsg    to save messages to file  #
#####################################################################
## Known bug: message numbers are sorted alphabetically, so if you have 11
## messages they'll be played: 1, 10, 11, 2, 3,..., 8, and 9.  -Jolo

############### RECORD SWITCH

## Recorder will record any messages while you are away by default,
## change the next line if you dont want it that way .. 
^assign record_when_away YES

^assign record_status OFF

############ /RECORD

alias record {
if ([$0]) {
  ^assign record_status $0
  if ([$record_status] == [on]) {
  ^assign record_status ON
  start_answering_machine
  echo #*#* Answering Machine has been set to  ON 
  } {
    ^assign record_status OFF
     stop_answering_machine
    echo #*#* Answering Machine has been set to  OFF 
  } 
}{
echo #*#* Usage: /record on | off   Sets your answering machine to ON or OFF
echo #*#* Other: /play              Plays  back your messages
echo #*#*      : /erase   [#'s]     Erases messages         [none specified = all]
echo #*#*      : /savemsg [#'s]     Saves  messages to disk [none specified = all]
echo #*#*      : /playmsg           Plays  messages previously saved to disk
echo ->>  Current Answering Machine Status:  $record_status 
 }
}

@record_msg = 0

alias start_answering_machine {

#^on #^notice -294 * {
#^assign message_nick $0
#^assign message_addr $strip(#~ $userhost())
#@message_in = [$1-]
#@message_time = mid(4 15 $STIME($TIME()) )
#recordmessages
#}

^on #^msg -294 * {
^assign message_nick $0
^assign message_addr $strip(#~ $userhost())
@message_in = [$1-]
@message_time = mid(4 15 $STIME($TIME()) )
recordmessages
}

}

alias stop_answering_machine {
^on #^notice -294 -*
^on #^msg -294 -*
}

alias recordmessages {
@record_msg = record_msg + 1
^assign recordmsga.$record_msg $message_nick
^assign recordmsgb.$record_msg $message_addr
^assign recordmsgc.$record_msg $message_in
^assign recordmsgd.$record_msg $message_time
}

############ /PLAY

alias play {
^set hold_mode on
echo Hold mode is on!  Number of messages: $record_msg 
echo Message    Nick        Address                               Date/Time
echo -------    ----        -------                               ---------
foreach recordmsga rm {
echo $[3]{rm}        $[9]recordmsga[$rm]   $[35]recordmsgb[$rm]   $recordmsgd[$rm]
echo ->  $recordmsgc[$rm]
echo ------------------------------------------------------------------------------
     }
#^set hold_mode off
}

############ /ERASE

alias erase {
set hold_mode off
if ([$0]) {
  @ind=0
  while ( word($ind $0-) ) {
     if ([$(recordmsga.$word($ind $0-))]) {
        echo #*#* Erasing message # : $word($ind $0-)
        ^assign -recordmsga.${word($ind $0-)}
        ^assign -recordmsgb.${word($ind $0-)}
        ^assign -recordmsgc.${word($ind $0-)}
        ^assign -recordmsgd.${word($ind $0-)}
        } {
            if ([$0] == [\*]) {erase_all_messages} {
                  echo #*#* That message does not exist ! \($word($ind $0-)\)
             }
           }
    @ind=ind+1
     }
echo #*#* DONE !
  }{erase_all_messages}

}

alias erase_all_messages {
echo #*#* Erasing ALL your Messages.....
foreach recordmsga rm {
     ^assign -recordmsga[$rm]
     ^assign -recordmsgb[$rm]
     ^assign -recordmsgc[$rm]
     ^assign -recordmsgd[$rm]
     }
@record_msg = 0
echo #*#* DONE !
}

############ /SAVEMSG

alias savemsg {
if ([$0]) {
echo #*#* Saving your messages in file 'messagebox' ... Be patient !
exec -name savemsg echo '$encode(Message    Nick        Address                               Date/Time)' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(-------    ----        -------                               ---------)' >> messagebox
wait %savemsg
  @ind=0
  while ( word($ind $0-) ) {
     if ([$(recordmsga.$word($ind $0-))]) {
        echo #*#* Saving message # : $word($ind $0-)
exec -name savemsg echo '$encode($[3]{word($ind $0-)}        $[9](recordmsga.$word($ind $0-))   $[35](recordmsgb.$word($ind $0-))   $(recordmsgd.$word($ind $0-)))' >> messagebox
wait %savemsg
exec -name savemsg echo ' ' >> messsagebox
wait %savemsg
exec -name savemsg echo '$encode(->  $(recordmsgc.$word($ind $0-)))' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(------------------------------------------------------------------------------)' >> messagebox   
wait %savemsg
        } {
            if ([$0] == [\*]) {save_all_messages} {
                  echo #*#* That message does not exist ! \($word($ind $0-)\)
             }
           }
    @ind=ind+1
     }
echo #*#* DONE !
  }{save_all_messages}
}

alias save_all_messages {
echo #*#* Saving ALL your Messages in file 'messagebox' ... Be patient !
exec -name savemsg echo '$encode(Message    Nick        Address                               Date/Time)' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(-------    ----        -------                               ---------)' >> messagebox
wait %savemsg
foreach recordmsga rm {
exec -name savemsg echo '$encode($[3]{rm}        $[9]recordmsga[$rm]   $[35]recordmsgb[$rm]   $recordmsgd[$rm])' >> messagebox
wait %savemsg
exec -name savemsg echo ' ' >> messsagebox
wait %savemsg
exec -name savemsg echo '$encode(->  $recordmsgc[$rm])' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(------------------------------------------------------------------------------)' >> messagebox   
wait %savemsg
     }
echo #*#* DONE !
}

############ /PLAYMSG

on ^exec "playmsg *" echo $decode($1-)

alias playmsg {
echo #*#* Playing your messages from file 'messagebox'
exec -name playmsg cat ./messagebox
wait %playmsg
}

############ /AWAY

on ^idle 15 away_check
alias away_check {
   ^assign -away_status
    userhost $N -cmd ^assign away_status $$2
    wait
    if ([$away_status] == [\-]) {
    if ([$record_when_away] == [YES]) {
     #//away 15-minute auto-away, msgs are being saved
     //away prob working for a change
    ^assign record_status ON
     start_answering_machine
      }
		{//away prob working for a change}
    }
}

alias away {
if ([$0]) {
 if ([$record_when_away] == [YES]) {
 ^assign away_msg $0- : msgs are being saved
 //away $away_msg
 ^assign record_status ON
 start_answering_machine
 }{//away //away $0-}
} {//away;stop_answering_machine;^assign record_status OFF}
}

########################### END OF ANSWERING MACHINE !

##################################
# /PAUSE to put pause mode on    #
# /PAUSE to return to normal     #
# /UNPAUSE for the skepticals :p #
# TG!cedras@rahul.net            #
##################################
alias pause {
  if (!pauseset) {
    ^SET HOLD_MODE ON
    @pauseset = [ON]
    echo #*#* In Pause Mode... (hit Enter/Return to continue scrolling if paused)
    } {
       if ([$pauseset] == [ON]) {
         ^SET HOLD_MODE OFF
         ^assign -pauseset
         echo #*#* Back to normal scroll mode ... (Pause Mode cancelled)
         } {}
       }
}

alias unpause {
@pauseset = [ON]
pause
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*#* END OF SUPERPAK STUFF, FOLLOWING IS CUSTOM STUFF BY JOLO & FRIENDS #*#*
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* Sends /notice to every channel op on current channel
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
alias wall
{
  ^assign -tmp.wall.str
  @ tmp.wall.cnt = 0
  while (word($tmp.wall.cnt $chanusers($C)))
  {
    if (ischanop($word($tmp.wall.cnt $chanusers($C)) $C))
      {@ tmp.wall.str = tmp.wall.str##[,$word($tmp.wall.cnt $chanusers($C))]}
    @ tmp.wall.cnt = tmp.wall.cnt + 1
  }
  ^notice $mid(1 500 $tmp.wall.str) [$C Ops] $0-
}


#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*           CTCP flood protection by Richard Hecker (garf@clo.com)
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* The author said: When I upgraded to 2.8.16, I realized that NO_CTCP_FLOOD
#* was completely broken, so I rewrote all CTCP handling in script...
#* Pro's:
#* - ignores all ctcp requests except: TIME, VERSION, PING, and ECHO
#* - does not respond to VERSIONs sent to a channel
#* - enforces a maximum of 1 CTCP reply sent out every 2 seconds.
#* Con's:
#* - breaks /IGNORE whatever CTCP ...But I've never been one to use /IGNORE...
#*     I just ignore stuff 'in my mind'

alias ctcprep
{
  if ((lastctcprep + 2) <= time())
    {notice $0 $1-}
    {xecho -l crap *** CTCP reply aborted: $*}
  @ lastctcprep = time()
}

alias nuhton {@ function_return = left($Index(! $0) $0)}

:The main script:

## finger, clientinfo, and userinfo are disabled for your own protection

on ^raw_irc "% privmsg % :finger*" xecho -l crap *** CTCP FINGER from 
$0 to $2: $strip( $4-) (ignored)
on ^raw_irc "% privmsg % :clientinfo*" xecho -l crap *** CTCP CLIENTINFO from $0 to $2: $strip( $4-) (ignored)
on ^raw_irc "% privmsg % :userinfo*" xecho -l crap *** CTCP USERINFO from $0 to $2: $strip( $4-) (ignored)

on ^raw_irc "% privmsg % :version*" {
  if (rmatch($2 &* #*))
  {
    xecho -l crap *** CTCP VERSION from $0 to $2: $strip( $4-) (ignored)
  }
  {
    xecho -l crap *** CTCP VERSION from $0 to $2: $strip( $4-)
    # version (the phrase between VERSION and :) is hardwired for now,
    # i'll try to fix that. For now, you should change it to your own.
    #ctcprep $nuhton($0) VERSION ircII 2.9_roof SunOS 5.5 : JoloPak $jp_version
    ctcprep $nuhton($0) VERSION $myversion: JoloPak $jp_version
  }
}

on ^raw_irc "% privmsg % :time*" {
  xecho -l crap *** CTCP TIME from $0 to $2: $strip( $4-)
  ctcprep $nuhton($0) TIME $stime($time())
}

on ^raw_irc "% privmsg % :ping*" {
  xecho -l crap *** CTCP PING from $0 to $2: $strip( $4-)
  ctcprep $nuhton($0) PING $strip( $4-)
}

on ^raw_irc "% privmsg % :echo*" {
  xecho -l crap *** CTCP ECHO from $0 to $2: $strip( $4-)
  ctcprep $nuhton($0) ECHO $strip( $4-)
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* ping myself every hour to keep from being disconnected for idling
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#alias brb msg #idler brb;timer 120 brb
ALIAS idlesafe /ctcp $N ping;timer 3600 idlesafe
idlesafe

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*   FINAL INSTRUCTIONS
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
eval echo * JoloPak $jp_version loaded *
## Uncomment following to make yourself "invisible" so you don't get flooded or
## spammed, but friends won't find you either unless they know your exact nick.
#eval //mode $N +i

SET DISPLAY ON
