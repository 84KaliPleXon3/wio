################*###############
#           JoloPak            #
#   version 1.0.3   96/07/23   #
# Jolo!jyl@deckard.mc.duke.edu #
################*###############
# This script is about 75% based on the widely available SuperPak, which is
# the most powerful non-war script.  It includes features such as /msg
# recording when you're /away, kicking and banning by nick, etc.
# I trimmed out a lot of the comments and useless functions, reducing it
# from nearly 4500 lines to less than 1000.
# The various SET settings are not really a script, but just good .ircrc
# settings courtesy of vert!csh@ripe.isdn.uiuc.edu.
#
# INSTALLATION:
#   Name it .ircrc and put it in your home directory.
#   Personalize the following block of lines.
#   Launch ircII -- that's it!
# ADVANCED USERS:
#   Customize your control key bindings (search forward for BIND).
#   Play with the SET settings (to learn their meanings, /help set).

# Customize the following block of lines to suit you.
# You should also change the user@host mask in 'pingsafe' near the end of this
# file (search for "jyl" below) to your own.

SET USER_INFORMATION Joseph Y. Lo, Ph.D.  I'm an assistant research professor in the radiology dept at Duke Univ Medical Center.  When I'm not on IRC or playing bolo, I do research in computer-aided diagnosis of mammography.  Check out the Internet Bolo League home page at http://deckard.mc.duke.edu/~jyl/IBL/ or the IRC help page at www.irchelp.org

SET HISTORY_FILE /home/jyl/IRC/history
SET LOAD_PATH .:/home/jyl:/home/jyl/IRC/CURRENT/script:/pkg/misc/lib/irc/script
SET LOGFILE /home/jyl/irclog
SET SHELL /usr/bin/tcsh
# Default ircII setup should use the following:
#SET HELP_PATH /usr/local/lib/irc/help
SET HELP_PATH /pkg/misc/lib/irc/help
#SET HELP_SERVICE ai-

# Following SET REALNAME disabled because it's better to set it globally.
# For csh/tcsh, add a line like this to your .cshrc in your home dir
# (only change what's in the double quotes):
#	setenv IRCNAME "Joseph Lo"
# For VMS, or other shells such as bash/msh/ksh/sh shells, ask me or a helper
# on EFnet channel #irchelp. -Jolo
# If you insist on doing this within .ircrc for some silly reason, here's how:
#SET REALNAME 'Joseph Lo, /ctcp Jolo userinfo'

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-
# From here on out, you don't need to change anything unless you're an
# advanced user who wants to customize things or to learn more about scripting.
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-

SET ALWAYS_SPLIT_BIGGEST ON
SET AUTO_NEW_NICK ON
SET AUTO_REJOIN ON
SET AUTO_UNMARK_AWAY ON
SET AUTO_WHOWAS ON
SET BEEP ON
SET BEEP_MAX 2
SET BEEP_ON_MSG MSG
SET BEEP_WHEN_AWAY 1
SET BOLD_VIDEO ON
SET CHANNEL_NAME_WIDTH 0
SET CLIENT_INFORMATION Running Jolopak, based on Barron's SuperPak
SET CLOCK OFF
SET CLOCK_24HOUR ON
SET CLOCK_ALARM OFF
SET CMDCHARS /
SET COMMAND_MODE OFF
SET CONTINUED_LINE    
SET DCC_BLOCK_SIZE 2048
SET DEBUG 0
SET DISPLAY OFF 
SET DISPLAY_ANSI OFF
SET EIGHT_BIT_CHARACTERS ON
# SET ENCRYPT_PROGRAM
SET EXEC_PROTECTION ON
SET FLOOD_AFTER 3
SET FLOOD_RATE 5
SET FLOOD_USERS 3
SET FLOOD_WARNING ON 
SET FULL_STATUS_LINE ON
SET HELP_PAGER ON
SET HELP_PROMPT OFF
SET HELP_WINDOW OFF
SET HIDE_PRIVATE_CHANNELS OFF
SET HIGHLIGHT_CHAR BOLD
SET HISTORY 150
SET HOLD_MODE OFF
SET HOLD_MODE_MAX 0
SET INDENT ON
SET INPUT_ALIASES ON
SET INPUT_PROMPT $T> 
SET INPUT_PROTECTION OFF
SET INSERT_MODE ON
SET INVERSE_VIDEO ON 
SET LASTLOG 2000 
SET LASTLOG_LEVEL DCC,ALL
SET LOG OFF
SET MAIL 0
SET MAX_RECURSIONS 10
# SET MINIMUM_SERVERS
# SET MINIMUM_USERS
SET MODE_STRIPPER ON
SET NOTIFY_HANDLERS NOISY
SET NOTIFY_LEVEL ALL
SET NOTIFY_ON_TERMINATION OFF
SET NOVICE OFF
SET NO_CTCP_FLOOD ON
SET NUM_OF_WHOWAS 1
SET PAD_CHAR -
SET PAUSE_AFTER_MOTD ON
SET SCROLL ON
SET SCROLL_LINES 1
# This gives you the satisfaction of taunting a flooder by telling him
# he is being ignored, but you can get flooded off yourself if this engages
# in response to a lot of clones.
SET SEND_IGNORE_MSG OFF
# SET SHELL_FLAGS
SET SHELL_LIMIT 0
SET SHOW_AWAY_ONCE ON
SET SHOW_CHANNEL_NAMES ON
SET SHOW_END_OF_MSGS OFF
SET SHOW_NUMERICS OFF
SET SHOW_STATUS_ALL OFF
SET SHOW_WHO_HOPCOUNT ON
SET STATUS_AWAY  (Away)
SET STATUS_CHANNEL  %C
SET STATUS_CHANOP @
SET STATUS_CLOCK  %T
SET STATUS_DQUERY DCC Querying %D
# following is original from vert
#SET STATUS_FORMAT %T [%R] %*%@%N%#%S%H%B%Q%A%C%+%I%O%M%F %U %W %C %C %C %C %C
# following is my shorter version
SET STATUS_FORMAT %T [%R] %*%@%N%#%S%H%B%Q%A%C%+%I%O%M%F %U %W %C 
SET STATUS_HOLD  Held:
SET STATUS_HOLD_LINES  %B
SET STATUS_INSERT
SET STATUS_MAIL  [Mail: %M]
SET STATUS_MODE  (+%+)
SET STATUS_NOTIFY  (W: %F)
SET STATUS_NO_REPEAT OFF
SET STATUS_OPER *
SET STATUS_OVERWRITE  (Overwrite)
SET STATUS_QUERY  (Query: %Q)
SET STATUS_SERVER  (%S)
SET STATUS_UMODE  (+%#)
SET STATUS_USER *
#SET STATUS_USER * type /help for help
SET STATUS_USER1
SET STATUS_USER2 
SET STATUS_USER3 
SET STATUS_USER4 
SET STATUS_USER5 
SET STATUS_USER6 
SET STATUS_USER7 
SET STATUS_USER8 
SET STATUS_USER9 
SET STATUS_WINDOW  ^^^^^^^^^
SET SUPPRESS_SERVER_MOTD ON
SET TAB_MAX 1
# SET TRANSLATION
SET UNDERLINE_VIDEO ON
SET USER_WALLOPS ON
SET USE_OLD_MSG OFF
SET VERBOSE_CTCP ON
SET WARN_OF_IGNORES ON
SET XTERM_OPTIONS

# The following loads various scripts and functions.  If you don't have them,
# it should simply say "file not found" and move on.
# If you used a default installation of ircII, especially ircII-EPIC,
# it should know where to look for these.  If you changed the script directory,
# then change the LOAD_PATH variable earlier. 
LOAD tabkey
LOAD killpath

# The following continues to load stuff, but these are not part of the standard
# ircII release, so if you're interested let me know and I might be able to
# release them to you.
LOAD .ircrc.aliases
LOAD NickCompleter.irc

# Following loads information which is private to me, please
# do not try to copy or distribute the files that it points to.  -Jolo
LOAD .ircrc.priv

# BIND META2-C YANK_FROM_CUTBUFFER
# BIND META2-D ERASE_TO_BEG_OF_LINE
#BIND ^N SCROLL_FORWARD
#BIND ^E SCROLL_END
BIND ^Q NEXT_WINDOW
BIND ^B SELF_INSERT
BIND META1-O META2
BIND META1-[ META2
BIND META2-A BACKWARD_HISTORY
BIND META2-B FORWARD_HISTORY
BIND META2-C FORWARD_CHARACTER
BIND META2-D BACKWARD_CHARACTER
BIND ^N SWITCH_CHANNELS
#BIND ^N NEXT_WINDOW
BIND ^P SCROLL_BACKWARD
## To flush server output
BIND ^S parse_command flush
BIND ^V SELF_INSERT
BIND ^_ SELF_INSERT

ALIAS 1 WINDOW GOTO 1
ALIAS 2 WINDOW GOTO 2

#Function to strip the less significant part of an internet hostname
alias userdomain {
  @ function_return = LEFT($INDEX(@ $0) $0)##[@]##MID(${1+INDEX(. $0)} 99 $0)
}

ON ^251 "*" {echo $n.o($H ***) $1 $2 ${[$3]+[$6]} $4 $8-}

# Following line is necessary otherwise will cut off flooding messages
# without warning to you (see /help set flood_warning)
ON ^FLOOD *

ON #^MSG 0 * ECHO *$0* $1-
ON ^NOTICE * ECHO -$0\- $1-
ON ^NOTIFY_SIGNOFF * ECHO --- Signoff: $0 
ON ^NOTIFY_SIGNON * ECHO +++ Signon: $0 $1
ON ^PUBLIC 10 * ECHO <$0> $2-
on public 20 from "* *beer *" do /me throws a cold one to $0
on public 30 from "* *jolo*" do echo 
on ^public_other * echo [$1] <$0> $2-
on ^send_msg * echo -> *$0* $1-
on ^send_notice * echo -> -$0\- $1-
on ^ctcp_reply "* ERRMSG *ACTION*" :
#on ^ctcp "* * *" {
#	/ignore * ctcp
#	echo *** CTCP $0 --> $1: $2
#	/timer -refnum 314 30 /ignore * -ctcp
#}
	
on ^002 * comment
on ^send_action * if ([$[1]0]!=[#])
  {echo === Describe [-> $0] : $N $1-}
  {echo === Action: $N $1-}
on ^action * if ([$[1]1]!=[#])
 {echo *** Describe: $0 $2-}
 {if ([$C]!=[$1]) {echo === Action [$1] : $0 $2-}
                  {echo === Action: $0 $2-}}
##DISPLAY YOUR NICK WHEN YOU TALK ON A CHANNEL
on ^send_public * {
	if ( [$0] == C ) { echo <$N> $1- } { echo -> <$0> $1- }
	#if ( [$0] == C ) { echo $N > $1- } { echo -> <$0> $1- }
}
##Put Hack notices down under
on ^SERVER_NOTICE "% \*\*\* Notice -- Hack: *" set status_user Hack: $5-
##Get rid of stupid 2.6 server messages "*** Nick: Channel not found"
on ^403 *

##############################################################################
# Following stuff until end of file is mostly from Barron's SuperPak script.
# Here are his original comments, which apply to my modifications as well...
###########################################################
# I AM NOT RESPONSIBLE AND SHOULD NOT BE HELD RESPONSIBLE #
# FOR ANY HARM OR DAMAGES CAUSED BY THIS SCRIPT           #
# ANY COMPLAINTS RECEIVED RESULTING FROM THE USE OF THESE #
# SCRIPTS WILL BE IGNORED !                               #
# USE AT YOUR OWN RISK !                                  #
###########################################################
# THIS SUPERPAK WAS CREATED TO INTRODUCE NEWBIES TO THE   #
# WONDERFUL WORLD OF IRC MACROS AND CUSTOMIZATIONS        #
# I VOID MASS ANYTHINGS (DEOP,KICK,MESSAGING...)          #
# SINCE THEY TEND TO MESS UP THE NET, AND I ALSO TRY TO   #
# AVOID AUTO-KICK SCRIPTS FOR I PERSONALLY FEEL A ROBOT   #
# IS MORE SUITED FOR THE JOB AND IT'S NOT AS LAME THAT WAY#
# THANX TO BARRON@DEATHSTAR.RESNET.UPENN.EDU FOR ALL HELP #
# AND CRITICISMS. ENJOY !                                 #
###########################################################

####################################################################
# MANY OF THE SCRIPTS IN SUPERPAK WERE TAKEN FROM THE SCRIPTS THAT #
# ACCOMPANIED THE IRCII CLIENT SOURCE AND WERE FROM THEIR ORIGINAL #
# AUTHORS.  IF YOU ARE THE ORIGINAL AUTHOR OF A SCRIPT AND WOULD   #
# LIKE YOUR NAME AND ADDRESS MENTIONED PROPERLY, EMAIL ME PROMPTLY #
####################################################################
# THE LATEST VERSION OF SUPERPAK CAN BE FOUND:                     #
# AT:   anonymous ftp: deathstar.texas.net                         #
#               login: anonymous                                   #
#                pass: your email address                          #
#                      cd /pub/irc/scripts                         #
# ON:   Ariela on IRC                                              #
# FROM: Barron (barron@texas.net)                                  #
#       ON IRC                                                     #
####################################################################

# Finger script III by Daemon.
# 4-05-93
# finger nickname         will finger the user@host of the nickname
# finger -h nickname      will finger the @host of the nickname
# finger user@host.name   will finger the given user@host
# finger @host.name       will finger the given @host.name
# 4-10-93
# Updated script to deal with output from 2.8.3-> servers. (# stuff)
# updated for 2.2.2

alias f finger

alias finger {
	^exec -kill %finger
	if (([$0] == [-h]) && ([$1] != []))
	{
		userhost $1 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching Host finger on:  $0 -> @$4 
                  eval exec -name finger exec finger @$$4 }
				{ echo *** FINGER: no such nickname $1 }
	}
	{
	if (index(@ $0) > -1)
	{
		exec -name finger exec finger $0
	}
	{
	if ([$0])
	{
		userhost $0 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching finger on: $0 $strip(#!> $3)@$4 
                  eval exec -name finger exec finger $strip(#~> $3)@$$4 }
				{ echo *** FINGER: no such nickname $0 }
	}
	{
		echo *** Usage: finger [[-h] <nickname>][[user]@full.hostname]
		echo *** e.g. finger bob, finger -h bob, finger robert@eff.org, or finger @eff.org
	}}}
}

##########################
##REPEAT /repeat (command)
##########################
alias repeat {
	@ rep.cnt = [$0]
	while ( rep.cnt > 0 )
	{
		$1-
		@rep.cnt = rep.cnt - 1
	}
	^assign -rep.cnt
}

########################################
#ONE STEP DEOP+TRADITIONAL BAN + KICK (/FUCK NICK)
########################################
alias fuck {
^assign -him
^assign him $0
^assign -fuck_comment
^assign fuck_comment $1-
userhost $him -cmd fuck2 $$0 $$3 $$4
}
alias fuck2 {
if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {fuck3 $0 $1 $2}
}
alias fuck3 {
^assign -nic
^assign -usr
^assign -mach
^assign -machine
^assign nic $0
^assign usr $strip(#~ $1)
^assign mach $2
^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
^assign machine *.$enleve($2)
//mode $C +bb *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
#//mode $C -o+bb $nic *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
if ([$fuck_comment]) {} {^assign fuck_comment $N}
//kick $C $nic ${fuck_comment}
}

######################
#TRADITIONAL BAN: /BAN NICK
######################
alias b ban

alias ban {
if ([$0]) {
^assign -him
^assign him $0
userhost $him -cmd ban2 $$0 $$3 $$4
} {mode $C +b}
}
alias ban2 {
if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {ban3 $0 $1 $2}
}
alias ban3 {
^assign -nic
^assign -usr
^assign -mach
^assign -machine
^assign nic $0
^assign usr $strip(#~ $1)
^assign mach $2
^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
^assign machine *.$enleve($2)
mode $C +b *!*$mid(0 8 $usr)*@$machine
}

########################
# /UNBAN <nick>        #
# to unban that person #
# TG!cedras@rahul.net  #
########################

# following commented out due to conflict w/ my /UB in .ircrc.aliases
#alias ub unban

alias unban {
  userhost $0 -cmd unban2 $$0 $$3 $$4
}

alias unban2 {
  if ([$2] == [<UNKNOWN>]) {
    echo *** $0: No such nick
  }{
    @ban_to_match = [$0] ## [\!] ## [$1] ## [@] ## [$2]
    unban3 
    }
}

alias unban3 {
  ^set display off
  ^assign -unban_those
  ^assign -channel_banlist
  ^on ^367 * {@channel_banlist = [$channel_banlist $2]}
  ^on ^368 * {
    ^on ^367 -*
    @ind_ban = 0
    while ( word($ind_ban $channel_banlist) ) 
     {
      @ban_scanned = word($ind_ban $channel_banlist)
      if ( [$rmatch($ban_to_match $ban_scanned)] || [$rmatch($ban_scanned $ban_to_match)]) 
       {    
        @unban_those = [$unban_those $ban_scanned]
        }
      @ind_ban = ind_ban + 1
      }
    ^on ^368 -*
    }
  //mode $C +b
  wait
  set display on
  apmode - b $unban_those
}

alias apmode {
  @ind=0
  while ( word($ind $2-) ) {
    if ( word($ind $4-) ) {
      mode * $0$1$1$1 $word($ind $2-) $word($ind $3-) $word($ind $4-)
    }{ if ( word($ind $3-) ) {
      mode * $0$1$1 $word($ind $2-) $word($ind $3-)
    }{
      mode * $0$1 $word($ind $2-)
    }}
    @ind=ind+3
  }
}

##############################################
#GET RID OF ANNOYBOTS AT ONCE (/rid one_of_the_bots_nick)
##############################################
alias rid {
  ^assign -mrlist
  ^assign -tomr
  @tomr=[$0-]
  ^on ^who * mrpattern $$1
  ^set display off
  ^who $C
  ^wait
  ^on ^who -*
  ^set display on
}
alias mrpattern {
 @mrmat=[$0]
  @ind2=0
   if ([$rmatch($mrmat $tomr)]) {userhost $mrmat -cmd ridem2 $$0 $$3 $$4}
}
alias ridem2 {
^assign -nic
^assign -usr
^assign -mach
^assign -machine
^assign nic $0
^assign usr $strip(#~ $1)
^assign usr *$usr
^assign mach $2
^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
^assign machine *.$enleve($2)
#mode $C -o+b $nic *!*@$machine
mode $C +b *!*@$machine
kick $C $nic
kk $mach
}
alias kk {
^assign -mkklist
^assign -tomkk
@tomkk=[$0-]
^on ^who * mkkpattern $$4 $$1
^set display off
^who $C
^wait
^on ^who -*
^set display on
}
alias mkkpattern {
@mkkmat=[$0]
@nicktokick=[$1]
if ([$rmatch($mkkmat $tomkk)]) {kick $C $nicktokick}
}

############################################
#         SHOWS USERS ON A CHANNEL         #
# usage: /look    or   /count   to display #
# or : /look #channel   or /count #channel #
# who is or how many on channel            #
# by TG!cedras@rahul.net                   #
# This sucker is faster then older code :) #
############################################

alias repeat {
	@ rep.cnt = [$0]
	while ( rep.cnt > 0 )
	{
		$1-
		@rep.cnt = rep.cnt - 1
	}
	^assign -rep.cnt
}


alias look {
   @whoonc = [yes]
   @on_channel = C
   if ([$0]) 
     {
      @on_channel = [$0]
      } 
  whoon
  }

alias count {
   @on_channel = C
  if ([$0]) 
   {
    @on_channel = [$0]
    } 
  whoon
  }

alias whoon {
   ^assign -total
   ^assign -wholist
   ^assign -whonum
   @opernum = 0
   @ircopnum = 0
   @nochop = 0	
   ^on ^who "*Channel*" /comment
   ^on ^who "*End of* /comment
   ^on ^who "*" whocount $$1 $$2
   ^who $on_channel
   ^wait
   @total = [$#whonum]
   @nochop = total - opernum
   if ( whoonc == [yes] ) {show_look $wholist}
   echo #*#* ON Channel ${on_channel}
   echo #*#* [TOTAL : $total users] [$opernum Chops] [$nochop NotChops] [$ircopnum IrcOPs]
   ^on ^who -
   ^assign whoonc no
  }
alias whocount {
   if ([$1]==[G@]||[$1]==[H@]||[$1]==[G*@]||[$1]==[H*@]) {@opernum=opernum+1}
   if ([$1]==[G*]||[$1]==[H*]||[$1]==[G*@]||[$1]==[H*@]) {@ircopnum=ircopnum+1}
   ^assign -dash_fill
   @diff = 0
   ^assign -nicklength
   @chanstat = [$1]
   if ([$@chanstat]==[1]) {@nickad = [$chanstat\-\-]}
   if ([$@chanstat]==[2]) {@nickad = [$chanstat\-]}
   if ([$@chanstat]==[3]) {@nickad = [$chanstat]}
   @nick = [$0\-$nickad]
   @nicklength = [$@nick]
   @diff = 13 - nicklength
   repeat $diff @dash_fill = dash_fill ## [-]
   ^assign enclosed [$dash_fill$nick]
   @wholist = [$wholist $enclosed]
   @whonum = [$whonum $1]
  }

alias show_look {
  @wholist_size = [$#wholist]
  @wholist_counter = 0
  while (wholist_counter < wholist_size) {
    @ind_wholist =0
    ^assign -wholist_display
    while (ind_wholist < 4) {
      ^assign wholist_display $wholist_display $word($wholist_counter $wholist)
      @ind_wholist = ind_wholist + 1
      @wholist_counter = wholist_counter + 1
      }
    echo ---> $wholist_display
    }
}

############# END OF /LOOK  /COUNT  FUNCTIONS

####################################
# SHOWS HOW LONG ONE HAS BEEN IDLE #
####################################
# /idle <nick>
alias idle {
whois $0 $0
}

##########
#NSLOOKUP#
##########
# DEFINE THE NAME OF YOUR NSLOOKUP PROGRAM HERE
@nslprog = [nslookup]

alias nsl {
  ^assign -nslnick
  ^assign -nslnick2
  ^assign nslnick $0
  ^assign nslnick2 $0-
  userhost $nslnick -cmd do_nsl $$4
  }

alias do_nsl {
  if ([$0]==[<UNKNOWN>]) {nslookup $nslnick2} {nslookup $0}
  }

alias nslookup {
  ^assign nslooking $0-
  exec $nslprog $nslooking
}

# Ban info patch
on ^367 * if ([$4] != []) {echo *** $1 \($3 - $stime($4)) $2} {echo *** $1-}

# Topic info patch
on ^333 * echo *** Topic for $1 set by $2 on $stime($3)


### /lusers        info:
alias lusers {
  ^assign -remote_server
  if ([$0]) {
             ^on #^364 -54 * assign remote_server $$1
             ^set display off
             //links $0
             wait 
             ^on #^364 -54 -*
             }

  ^on ^251 * {
    ^assign -nusers
    ^assign -nusersi
    ^assign -nservers
    ^assign nusers $3
    ^assign nusersi $6
    ^assign nservers $9
    @nuserst = nusers + nusersi
    echo *** There are $nuserst users \($nusers + $nusersi invisible\) on $nservers servers
    }

  ^on ^252 * echo *** $$1 IRC op(s) online

  ^on ^254 * echo *** There are $$1 channels

  ^on ^255 * {
    ^assign -musers
    ^assign musers $3
    ^assign -nusersp
    ^assign -nusersp2
    echo *** Connected to me are $musers users and $6 servers
    @nusersp = musers * 100
    @nusersp2 = nusersp / nuserst
    echo *** I have $musers out of a total of $nuserst users \(about $nusersp2 \% of total)
    }
  //lusers $remote_server
  wait
  ^on ^251 -*
  ^on ^252 -*
  ^on ^254 -*
  ^on ^255 -*
}

###########################
#  IGNORING FUNCTION      #
#  BY TG!cedras@rahul.net #             
#  /ig /uig /sig /zig     #
###########################

alias shoo {
	userhost $, -cmd ^assign hostig $$3@$$4
	ignore $hostig msg
	timer 60 ignore $hostig -msg
	^assign -hostig
}

# typing ctrl-o will ignore the last person who sent you a message
BIND ^o parse_command ig2 $,

## IGNORING (/ig <nick> or <whatever>)

alias ig {
  if ([$0]) {
    ^assign -ignick
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_ig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      ^assign ignore_list $ignore_list $0
      echo #*#*#  $ignick \( $ignick \) is been ignored !
      #//^ignore $ignick all
      //^ignore $ignick all -crap
      @igflag = 0
      }
     }{
       echo *** USAGE: To ignore someone completely: /ig <nick> or <address>
	}
  }

alias do_ig {
  if ([$0]!=[<UNKNOWN>]) {add_iglist $0 $1}
  }

alias add_iglist {
  @igflag = 1

  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  ^assign ignore_list $ignore_list $igfinal
  echo #*#*#  $ignick \( $igfinal \) is been ignored !
  //^ignore $igfinal all
  }

alias ig2 {
  if ([$0]) {
    ^assign -ignick
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_ig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      ^assign ignore_list $ignore_list $0
      echo #*#*#  $ignick \( $ignick \) is been ignored !
      //^ignore $ignick msgs walls wallops invites notices notes ctcps crap
      @igflag = 0
      }
     }{
       echo *** USAGE: To ignore someones hostname completely: /ig2 <nick> or <address>
       }
  }

alias do_ig {
  if ([$0]!=[<UNKNOWN>]) {add_iglist $0 $1}
  }

alias add_iglist {
  @igflag = 1

  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*@$machine]
  ^assign ignore_list $ignore_list $igfinal
  echo #*#*#  $ignick \( $igfinal \) is been ignored !
  //^ignore $igfinal msgs walls wallops invites notices notes ctcps crap
  }


## UNIGNORING (/uig <nick> or <whatever>)

alias uig {
  if ([$0]) {
    ^assign -ignick
    ^assign -igfinal
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_nig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      @ignore_list = [$remove_word($0 $ignore_list)]
      echo #*#*#  $ignick \( $ignick \) is being removed from ignorance !
      //ignore $ignick none
      @igflag = 0
      }
    }{
      echo *** USAGE: To remove someone from ignorance list /uig <nick> or <address>
   }
 }

alias do_nig {
  if ([$0]!=[<UNKNOWN>]) {remove_iglist $0 $1}
}

alias remove_iglist {
  @igflag = 1
  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  @ignore_list = [$remove_word($igfinal $ignore_list)]
  echo #*#*#  $ignick \( $igfinal \) is being removed from ignorance !
  //ignore $igfinal none
  }

## SHOW IGNORE LIST (/sig)

alias sig echo #*#*# My_Ignorance_List:;echo ->>   $ignore_list

## ZAP IGNORE LIST (/zig)

alias zig {
  @ind=0
  while ( word($ind $ignore_list-) ) {
    //ignore $word($ind $ignore_list) none
    @ind=ind+1
  }
  ^assign -ignore_list
  echo #*#*# Ignorance list has been cleared !
  }


################# SPECIAL FUNCTIONS bye Jeremy Nelson   hop!jnelson@iastate.edu
alias leftw {
    @ function_return = [$(1-$0)]
}
alias restw {
    @ function_return = [$(${[$0]+1}-)]
}
alias notw {
    if ([$0])
       {@ _pad = [ ]}
       {@ _pad = []}
    @ _words = [$1-]
    @ function_return = [$leftw($0 $1-)] ## [$_pad] ## [$restw(${[$0]+1} $1-)]
}

alias remove_word {
    @ _pattern = rmatch($0 $1-) - 1
    if (_pattern != -1)
       {@ function_return = notw($_pattern $1-)}
       {@ function_return = [$1-]}
}

################# END OF IGNORE FUNCTION

######################################
# SMART /CHAT INTERFACE              #
# BY TG!cedras@rahul.net             #
######################################
# to initiate a chat connection      #
# -> type: /chat <nickname>          #
# to close current connection and    #
# initiate another                   #
# -> type: /chat <new nickname>      #
# to connect to a chat request       #
# -> type: /chat                     #
# to close current connection and    #
# respond to a request               #
# -> type: /chat                     #
# to close a chat connection         #
# -> type: /chat                     #
#                                    #
# /autoquery on | off   to set auto  #
#                       query mode   #
######################################


########### SMART /CHAT INTERFACE

on ^ctcp "% % DCC CHAT % *" {
@chat_request = [$0]
}


alias chat {
if (![$chat_current] && ![$chat_request] && ![$0] ) {
echo #*#* No chat requests issued to you or nickname Specified
}{
  if (chat_current)
   {
    //dcc close chat $chat_current
    ^assign -chat_current
    if ([$auto_query] == [on]) {//query}
    }
  if ([$0])
   {
   //dcc chat $0
   @chat_current = [$0]
   if ([$auto_query] == [on]) {//query =$chat_current}
   ^assign -chat_request
    } {
      if (chat_request)
       {
       //dcc chat $chat_request
       @chat_current = chat_request
       if ([$auto_query] == [on]) {//query =$chat_current}
       ^assign -chat_request
        }
       }
    }
}

############### AUTO_QUERY SWITCH

# AUTOQUERY IS ON BY DEFAULT, CHANGE THE NEXT LINE IF YOU DONT
# WANT IT THAT WAY
^assign auto_query ON
####################


alias autoquery {
if ([$0]) {
  ^assign auto_query $0
  if ([$auto_query] == [on]) {
  ^assign auto_query ON
  echo #*#* Auto-Query has been set to  ON 
  } {
    ^assign auto_query OFF
    echo #*#* Auto-Query has been set to  OFF 
  } 
}{
echo #*#* Usage: /autoquery on | off   to set your auto-query mode
echo #*#*        Puts you automatically in query mode on a dcc chat if set to ON
echo ->>  Current Auto Query Status:  $auto_query 
 }
}


################## END OF /CHAT  FUNCTION

#########################################
#         IRC Answering Machine         #
#        by  TG!cedras@rahul.net        #       
#########################################
# This Script records all incoming      #
# Messages and Notices to you whether   #
# You are present or away               #
# *hysterical laughs*   Yes ! :-)       #
# We have indeed gone mad :)            #
#########################################
# How to Use:                           #
# /record     tells your machine status #
# /record ON  to set machine ON         #
# /record OFF to set machine OFF        #
# /play       to play back your msgs    #
# /erase      to erase messages         #
# /playmsg    to play back message file #
# /savemsg    to save messages to file  #
#####################################################################
# I Wrote this script unaware that some people had done it before   #
# me, and while testing it, Mmmm (Mandar M. Mirashi) mentioned a    #
# script by Tychy which he sent to me.. I did not copy everything   #
# off tychy, mainly some of the aesthetics but the main routines are#
# Mine, but I do give credit to Tychy for his work as well .. :)    #
#####################################################################

############### RECORD SWITCH

# RECORDER WILL RECORD ANY MESSAGES SENT WHILE
# YOU ARE AWAY BY DEFAULT, 
# CHANGE THE NEXT LINE IF YOU DONT WANT IT THAT WAY .. 

^assign record_when_away YES
####################
^assign record_status OFF

############ /RECORD

alias record {
if ([$0]) {
  ^assign record_status $0
  if ([$record_status] == [on]) {
  ^assign record_status ON
  start_answering_machine
  echo #*#* Answering Machine has been set to  ON 
  } {
    ^assign record_status OFF
     stop_answering_machine
    echo #*#* Answering Machine has been set to  OFF 
  } 
}{
echo #*#* Usage: /record on | off   Sets your answering machine to ON or OFF
echo #*#* Other: /play              Plays  back your messages
echo #*#*      : /erase   [#'s]     Erases messages         [none specified = all]
echo #*#*      : /savemsg [#'s]     Saves  messages to disk [none specified = all]
echo #*#*      : /playmsg           Plays  messages previously saved to disk
echo ->>  Current Answering Machine Status:  $record_status 
 }
}

@record_msg = 0

alias start_answering_machine {

#^on #^notice -294 * {
#^assign message_nick $0
#^assign message_addr $strip(#~ $userhost())
#@message_in = [$1-]
#@message_time = mid(4 15 $STIME($TIME()) )
#recordmessages
#}

^on #^msg -294 * {
^assign message_nick $0
^assign message_addr $strip(#~ $userhost())
@message_in = [$1-]
@message_time = mid(4 15 $STIME($TIME()) )
recordmessages
}

}


alias stop_answering_machine {
^on #^notice -294 -*
^on #^msg -294 -*
}


alias recordmessages {
@record_msg = record_msg + 1
^assign recordmsga.$record_msg $message_nick
^assign recordmsgb.$record_msg $message_addr
^assign recordmsgc.$record_msg $message_in
^assign recordmsgd.$record_msg $message_time
}

############ /PLAY

alias play {
^set hold_mode on
echo Hold mode is on!  Number of messages: $record_msg 
echo Message    Nick        Address                               Date/Time
echo -------    ----        -------                               ---------
foreach recordmsga rm {
echo $[3]{rm}        $[9]recordmsga[$rm]   $[35]recordmsgb[$rm]   $recordmsgd[$rm]
echo ->  $recordmsgc[$rm]
echo ------------------------------------------------------------------------------
     }
#^set hold_mode off
}

############ /ERASE

alias erase {
set hold_mode off
if ([$0]) {
  @ind=0
  while ( word($ind $0-) ) {
     if ([$(recordmsga.$word($ind $0-))]) {
        echo #*#* Erasing message # : $word($ind $0-)
        ^assign -recordmsga.${word($ind $0-)}
        ^assign -recordmsgb.${word($ind $0-)}
        ^assign -recordmsgc.${word($ind $0-)}
        ^assign -recordmsgd.${word($ind $0-)}
        } {
            if ([$0] == [\*]) {erase_all_messages} {
                  echo #*#* That message does not exist ! \($word($ind $0-)\)
             }
           }
    @ind=ind+1
     }
echo #*#* DONE !
  }{erase_all_messages}

}


alias erase_all_messages {
echo #*#* Erasing ALL your Messages.....
foreach recordmsga rm {
     ^assign -recordmsga[$rm]
     ^assign -recordmsgb[$rm]
     ^assign -recordmsgc[$rm]
     ^assign -recordmsgd[$rm]
     }
@record_msg = 0
echo #*#* DONE !
}

############ /SAVEMSG

alias savemsg {
if ([$0]) {
echo #*#* Saving your messages in file 'messagebox' ... Be patient !
exec -name savemsg echo '$encode(Message    Nick        Address                               Date/Time)' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(-------    ----        -------                               ---------)' >> messagebox
wait %savemsg
  @ind=0
  while ( word($ind $0-) ) {
     if ([$(recordmsga.$word($ind $0-))]) {
        echo #*#* Saving message # : $word($ind $0-)
exec -name savemsg echo '$encode($[3]{word($ind $0-)}        $[9](recordmsga.$word($ind $0-))   $[35](recordmsgb.$word($ind $0-))   $(recordmsgd.$word($ind $0-)))' >> messagebox
wait %savemsg
exec -name savemsg echo ' ' >> messsagebox
wait %savemsg
exec -name savemsg echo '$encode(->  $(recordmsgc.$word($ind $0-)))' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(------------------------------------------------------------------------------)' >> messagebox   
wait %savemsg
        } {
            if ([$0] == [\*]) {save_all_messages} {
                  echo #*#* That message does not exist ! \($word($ind $0-)\)
             }
           }
    @ind=ind+1
     }
echo #*#* DONE !
  }{save_all_messages}
}


alias save_all_messages {
echo #*#* Saving ALL your Messages in file 'messagebox' ... Be patient !
exec -name savemsg echo '$encode(Message    Nick        Address                               Date/Time)' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(-------    ----        -------                               ---------)' >> messagebox
wait %savemsg
foreach recordmsga rm {
exec -name savemsg echo '$encode($[3]{rm}        $[9]recordmsga[$rm]   $[35]recordmsgb[$rm]   $recordmsgd[$rm])' >> messagebox
wait %savemsg
exec -name savemsg echo ' ' >> messsagebox
wait %savemsg
exec -name savemsg echo '$encode(->  $recordmsgc[$rm])' >> messagebox   
wait %savemsg
exec -name savemsg echo '$encode(------------------------------------------------------------------------------)' >> messagebox   
wait %savemsg
     }
echo #*#* DONE !
}

############ /PLAYMSG

on ^exec "playmsg *" echo $decode($1-)

alias playmsg {
echo #*#* Playing your messages from file 'messagebox'
exec -name playmsg cat ./messagebox
wait %playmsg
}

############ /AWAY

on ^idle 15 away_check
alias away_check {
   ^assign -away_status
    userhost $N -cmd ^assign away_status $$2
    wait
    if ([$away_status] == [\-]) {
	pingsafe on
    if ([$record_when_away] == [YES]) {
     #//away 15-minute auto-away, msgs are being saved
     //away prob working for a change
    ^assign record_status ON
     start_answering_machine
      }
		{//away prob working for a change}
    }
}

alias away {
if ([$0]) {
 if ([$record_when_away] == [YES]) {
 ^assign away_msg $0- : msgs are being saved
 //away $away_msg
 ^assign record_status ON
 start_answering_machine
 }{//away //away $0-}
} {//away;stop_answering_machine;^assign record_status OFF}
}

########################### END OF ANSWERING MACHINE !

##################################
# /PAUSE to put pause mode on    #
# /PAUSE to return to normal     #
# /UNPAUSE for the skepticals :p #
# TG!cedras@rahul.net            #
##################################
alias pause {
  if (!pauseset) {
    ^SET HOLD_MODE ON
    @pauseset = [ON]
    echo #*#* In Pause Mode... (hit Enter/Return to continue scrolling if paused)
    } {
       if ([$pauseset] == [ON]) {
         ^SET HOLD_MODE OFF
         ^assign -pauseset
         echo #*#* Back to normal scroll mode ... (Pause Mode cancelled)
         } {}
       }
}

alias unpause {
@pauseset = [ON]
pause
}
################ END OF PAUSE FUNCTION

################# auto set topic #################
alias topic_timer {
	eval timer -ref 100 7200 topic_set
}
alias topic_set {
	wait -cmd topic_timer
	topic #bolo FAQ http://deckard.mc.duke.edu/~jyl/IBL/
	timer -ref 101 3600 topic #bolo official home page http://www.thoughtport.com/bolo/
}
#topic_timer

###################################################################
# PINGSAFE AUTOPINGS YOU SO YOU DON'T PING TIME-OUT OF IRC
assign ps_status off
alias ps_on {
  ^assign ps_status on
  @seed=[$srand($rand($time()))]
  @ps_time=[$rand(180)]+1
  eval timer -ref 366 $ps_time psafe
}
alias ps_off {
  ^assign ps_status off
  eval timer -del 366
}
alias psafe {
  wait -cmd ps_on
  ^ping $N
  #ctcp $N ping
}
alias pingsafe {
  if ([$0])
  {
    ^assign ps_status $0
    if ([$ps_status] == [on]) {^eval ignore jyl@*.duke.edu ctcp;ps_on}
    if ([$ps_status] == [off]) {^eval ignore jyl@*.duke.edu -ctcp;ps_off}
  }
  echo ==> Pingsafe has been set to $ps_status <==.
}
pingsafe on

###############################################################################
#   FINAL INSTRUCTIONS
###############################################################################
SET DISPLAY ON
