##             +==========================================+
##             |          JoloPak ircII script            |
##             |   Joseph Lo (jolo@deckard.mc.duke.edu)   |
##             |  http://www.irchelp.org/irchelp/script/  |
##             | ftp://ripley.mc.duke.edu/Ripley/pub/irc/ |
##             +==========================================+
##  Please don't change the next few lines, it just makes it more confusing if
##  I try to help you debug problems and can't even tell what version you have.
assign jp_version 1.1.1
assign jp_date (3/08/97 1:45am)
alias version {
	//version
	echo *** Running JoloPak $jp_version $jp_date
}

## INTRODUCTION:
##   JoloPak is a convenience script partly based on Barron's SuperPak,
##   a long (4500 lines!) non-war script pack. I trimmed away 3/4 of the
##   lard and added many kewl new features courtesy of fellow #IRChelp ops.
##   JoloPak comes with built-in help (type /jhelp) but otherwise we
##   regret that we can't provide script help on #IRChelp.

## INSTALLATION:
## I recommend that you don't change this jolopak.scr file. Instead customize
## a ".ircrc" setup file which is run first every time you launch ircII.
## Then you can upgrade to newer JoloPaks in the future without having to redo
## all your customizations. You can get a sample .ircrc file from:
##    <http://www.irchelp.org/irchelp/script/ircrc.txt> or
##    <ftp://ripley.mc.duke.edu/Ripley/pub/irc/ircrc.txt>.

## If you prefer to do it all yourself anyway, here's how you can turn
## jolopak.scr into your default .ircrc script.
##   1. Save the file as .ircrc in your shell account home directory.
##   2. Personalize "myversion", "myhome" and "SET USER_INFORMATION" below.
##   3. If you installed ircII yourself, verify the LOAD_PATH and HELP_PATH.
## Now Launch ircII as usual (usually type "irc") -- that's it!

## Put your home directory after 'myhome' below (to find your home directory,
## at the UNIX prompt type "echo $HOME", or "cd" followed by "pwd".

assign myhome /home/jyl

## Change "myversion" to whatever version you are running: launch IRC without
## any scripts by "irc -q", then /ctcp your_nick version, copy everything
## after "CTCP VERSION reply from your_nick:" and paste it below.

assign myversion ircII 2.9_roof SunOS 5.5

## The following line is returned to anybody doing /ctcp your_nick userinfo
## This is your chance to be creative - don't mess with other CTCP responses!

assign myuserinfo The name is Bond, James Bond. I like a dry vodka martini, shaken, not stirred, with a twist of lemon peel.

## By default ircII support files are installed in /usr/local/lib/irc/,
## if you installed them elsewhere, change the following 2 lines accordingly.

eval SET LOAD_PATH .:$myhome:/usr/local/lib/irc/script
SET HELP_PATH /usr/local/lib/irc/help

## If you don't have /help, uncomment this to use "ai-" the EFnet help bot.
## (Any line starting with `#` is a comment, delete the `#` to activate it.)
## or use the WWW help files at http://www.irchelp.org/irchelp/ircii
#SET HELP_SERVICE ai-

##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
## From here on out, you don't need to change anything unless you want to
## customize things or to learn more about scripting. For example, you may:
##   1. Customize the SET and ALIAS commands below.
##   2. Customize the control key BIND commands at the end of the script.
##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

#*#*#*##*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
#*             A L I A S E S              *#
#*#*#*##*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

ALIAS DNS EXEC nslookup $0
ALIAS F //CTCP $0 FINGER
ALIAS IDLE {WHOIS $0 $0}
ALIAS J //JOIN $0
ALIAS M //msg $0-
ALIAS N if ([$0]) {//names $0-} {//names $C}
ALIAS P //CTCP $0 PING $time()
ALIAS PART if ([$0]) {//part $0-} {//part $C}
ALIAS RELOAD LOAD .ircrc
ALIAS SLAP /me slaps a large trout around a bit with $0
ALIAS T if (index(#*& $[1]0) > -1) { ${K}${K}topic $*} { ${K}${K}topic $C $*}
ALIAS V //CTCP $0 VERSION
ALIAS W //WHOIS $0
ALIAS H+ SET HOLD_MODE ON
ALIAS H- SET HOLD_MODE OFF

##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
## These settings affect how ircII behaves, use /help before changing anything.
##-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
##    Most of these are the same as ircII's default settings, but I list them
##    so you can learn more about them, such as: /help set always_split_biggest

SET ALWAYS_SPLIT_BIGGEST ON
SET AUTO_WHOWAS ON
SET BEEP ON
SET BEEP_MAX 2
SET BEEP_ON_MSG MSG
SET BEEP_WHEN_AWAY 1
SET BOLD_VIDEO ON
SET CHANNEL_NAME_WIDTH 0
SET CLOCK OFF
SET CLOCK_24HOUR ON
SET CLOCK_ALARM OFF
SET CMDCHARS /
SET COMMAND_MODE OFF
SET CONTINUED_LINE    
SET DCC_BLOCK_SIZE 2048
SET DEBUG 0
SET DISPLAY OFF
SET DISPLAY_ANSI OFF
SET EIGHT_BIT_CHARACTERS ON
SET EXEC_PROTECTION ON
SET FLOOD_AFTER 5
SET FLOOD_RATE 3
SET FLOOD_USERS 3
SET FLOOD_WARNING ON
SET FULL_STATUS_LINE ON
SET HELP_PAGER ON
SET HELP_PROMPT ON
SET HELP_WINDOW OFF
SET HIDE_PRIVATE_CHANNELS OFF
SET HIGHLIGHT_CHAR BOLD
eval SET HISTORY_FILE $myhome/history
SET HISTORY 150
SET HOLD_MODE OFF
SET HOLD_MODE_MAX 0
SET INDENT ON
SET INPUT_ALIASES OFF
SET INPUT_PROMPT $T> 
SET INPUT_PROTECTION OFF
SET INSERT_MODE ON
SET INVERSE_VIDEO ON
SET LASTLOG 1000
SET LASTLOG_LEVEL DCC,ALL
eval SET LOGFILE $myhome/irclog
SET LOG OFF
SET MAIL 0
SET MAX_RECURSIONS 10
SET MODE_STRIPPER ON
SET NOTIFY_HANDLERS NOISY
SET NOTIFY_LEVEL ALL
SET NOTIFY_ON_TERMINATION OFF
SET NOVICE OFF
SET NO_CTCP_FLOOD ON
SET NUM_OF_WHOWAS 1
SET PAD_CHAR -
SET PAUSE_AFTER_MOTD ON
SET SCROLL ON
SET SCROLL_LINES 1
SET SEND_IGNORE_MSG OFF
SET SHELL_LIMIT 0
SET SHOW_AWAY_ONCE ON
SET SHOW_CHANNEL_NAMES ON
SET SHOW_END_OF_MSGS OFF
SET SHOW_NUMERICS OFF
SET SHOW_STATUS_ALL OFF
SET SHOW_WHO_HOPCOUNT ON
SET STATUS_AWAY  (Away)
SET STATUS_CHANNEL  %C
SET STATUS_CHANOP @
SET STATUS_CLOCK  %T
SET STATUS_DQUERY DCC Querying %D
SET STATUS_FORMAT %T [%R] %*%@%N%#%S%H%B%Q%A%C%+%I%O%M%F %U %W %C 
SET STATUS_HOLD  Held:
SET STATUS_HOLD_LINES  %B
SET STATUS_INSERT
SET STATUS_MAIL  [Mail: %M]
SET STATUS_MODE  (+%+)
SET STATUS_NOTIFY  (W: %F)
SET STATUS_NO_REPEAT OFF
SET STATUS_OPER *
SET STATUS_OVERWRITE  (Overwrite)
SET STATUS_QUERY  (Query: %Q)
SET STATUS_SERVER  (%S)
SET STATUS_UMODE  (+%#)
SET STATUS_USER *
SET STATUS_USER1
SET STATUS_USER2
SET STATUS_USER3
SET STATUS_USER4
SET STATUS_USER5
SET STATUS_USER6
SET STATUS_USER7
SET STATUS_USER8
SET STATUS_USER9
SET STATUS_WINDOW  ^^^^^^^^^
SET SUPPRESS_SERVER_MOTD ON
SET TAB_MAX 1
SET UNDERLINE_VIDEO ON
SET USER_WALLOPS ON
SET USE_OLD_MSG OFF
SET VERBOSE_CTCP ON
SET WARN_OF_IGNORES ON
SET XTERM_OPTIONS

## The following loads useful built-in ircII scripts.  If you don't have them,
## it should simply say "file not found" and move on - no harm done.

LOAD tabkey
LOAD killpath

## Following line is necessary otherwise will cut off flooding messages
## without warning to you (see /help set flood_warning)
ON ^FLOOD *
## Allow help messages from EFnet helper bot ai- to bypass flood control
on flood ^ai-

ON #^MSG 0 * ECHO *$0* $1-
ON ^NOTICE * ECHO -$0\- $1-
ON ^NOTIFY_SIGNOFF * ECHO --- Signoff: $0
ON ^NOTIFY_SIGNON * ECHO +++ Signon: $0 $1
ON ^PUBLIC 10 * ECHO <$0> $2-
on ^public_other * echo [$1] <$0> $2-
on ^send_msg * echo -> *$0* $1-
on ^send_notice * echo -> -$0\- $1-
on ^ctcp_reply "* ERRMSG *ACTION*" :

on ^002 * comment
on ^send_action * if ([$[1]0]!=[#])
  {echo === Describe [-> $0] : $N $1-}
  {echo === Action: $N $1-}
on ^action * if ([$[1]1]!=[#])
 {echo *** Describe: $0 $2-}
 {if ([$C]!=[$1]) {echo === Action [$1] : $0 $2-}
                  {echo === Action: $0 $2-}}
## Display your nick when you talk on a channel
on ^send_public * {
	if ( [$0] == C ) { echo <$N> $1- } { echo -> <$0> $1- }
}

## List users (/lusers) info patch:

alias lusers {

  ^on ^251 * {
    ^assign -nusers
    ^assign -nusersi
    ^assign -nservers
    ^assign nusers $3
    ^assign nusersi $6
    ^assign nservers $9
    @nuserst = nusers + nusersi
    echo *** There are $nuserst total users \($nusers + $nusersi invisible\) on $nservers servers
    }

  ^on ^252 * echo *** $$1 server operators online

  ^on ^255 * {
    ^assign -musers
    ^assign musers $3
    ^assign -nusersp
    ^assign -nusersp2
    @nusersp = musers * 100
    @nusersp2 = nusersp / nuserst
    echo *** This server has $musers users \(~ $nusersp2\% of total) and $6 servers connected to it
    }
  //lusers $remote_server
  wait
  ^on ^251 -*
  ^on ^252 -*
  ^on ^255 -*
}

# Ban info patch (such as from /bs)
on ^367 * if ([$4] != []) {echo *** $1 \($3: $stime($4)) $2} {echo *** $1-}

# Topic info patch
on ^333 * echo *** Topic for $1 set by $2 on $stime($3)

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*#*         FOLLOWING STUFF IS FROM BARRON'S SUPERPAK SCRIPT.          #*#*
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

#####################
#AUTO REJOIN ON KICK
#####################
# features built in 7 sec delay to make it look like a manual rejoin
# Auto-rejoin is OFF by default (many consider it very rude!)
^assign auto_rejoin ON

alias autorejoin {
if ([$0]) 
  {
  ^assign auto_rejoin $0
  if ([$auto_rejoin] == [on]) {
  ^assign auto_rejoin ON
  echo #*#* Auto-Rejoin has been set to  ON 
  } {
    ^assign auto_rejoin OFF
    echo #*#* Auto-Rejoin has been set to  OFF 
  } 
}{
echo #*#* Usage: /autorejoin on | off   to set your auto rejoin state
echo #*#*        Makes you rejoin a channel automatically if you are kicked off
echo ->>  Current Auto Rejoin Status:  $auto_rejoin 
 }
}

on -raw_irc "% KICK *" if ( ([$3] == [$N]) && ([$auto_rejoin] == [ON] ) ) { 
msg $N xtj $2 
echo Rejoining $2 in 7 secs, abort by typing: /timer -del 911
 }{}
on ^msg "% xtj *" if ( [$0] == [$N] ) { timer -refnum 911 7 join $2 }{}

################################
# Finger script III by Daemon.
################################
# finger nickname         will finger the user@host of the nickname
# finger -h nickname      will finger the @host of the nickname
# finger user@host.name   will finger the given user@host
# finger @host.name       will finger the given @host.name

alias finger {
	^exec -kill %finger
	if (([$0] == [-h]) && ([$1] != []))
	{
		userhost $1 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching Host finger on:  $0 -> @$4 
                  eval exec -name finger exec finger @$$4 }
				{ echo *** FINGER: no such nickname $1 }
	}
	{
	if (index(@ $0) > -1)
	{
		exec -name finger exec finger $0
	}
	{
	if ([$0])
	{
		userhost $0 -cmd if ([$3] != [<UNKNOWN>])
				{ echo *** Launching finger on: $0 $strip(#!> $3)@$4 
                  eval exec -name finger exec finger $strip(#~> $3)@$$4 }
				{ echo *** FINGER: no such nickname $0 }
	}
	{
		echo *** Usage: finger [[-h] <nickname>][[user]@full.hostname]
		echo *** e.g. finger bob, finger -h bob, finger robert@eff.org, or finger @eff.org
	}}}
}

## Jolo's note: The following are channel protection commands which will soon be
## replaced with much more powerful stuff in a separate, non-newbie script.

## Here are some simple channel maintenance aliases

## Op or Deop up to 4 nicknames
ALIAS CHOP MODE $C +oooo $0 $1 $2 $3
ALIAS DEOP MODE $C -oooo $0 $1 $2 $3

## Old fashioned kick, just /k nickname [optional reason]
ALIAS K {if ([$1]) {//kick $C $0 $1-} {//kick $C $0}}

## Unban the specified nick!user@host pattern (do /bs then copy & paste)
ALIAS UB //MODE $C -b $0

########################################
#ONE STEP KICK & BAN (/KB NICK [comment])
########################################
## Jolo's note: works with numeric IPs but only barely, will improve soon
alias kb {
	^assign -him
	^assign him $0
	^assign -fuck_comment
	^assign fuck_comment $1-
	userhost $him -cmd fuck2 $$0 $$3 $$4
}
alias fuck2 {
	if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {fuck3 $0 $1 $2}
}
alias fuck3 {
	^assign -nic
	^assign -usr
	^assign -mach
	^assign -machine
	^assign nic $0
	^assign usr $strip(#~ $1)
	^assign mach $2
	^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
	^assign machine *.$enleve($2)
	//mode $C +bb *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
	#//mode $C -o+bb $nic *!*$mid(0 8 $usr)*@$machine *!*$mid(0 8 $usr)*@*
	if ([$fuck_comment]) {} {^assign fuck_comment $N}
	//kick $C $nic ${fuck_comment}
}

######################
#TRADITIONAL BAN: /BAN NICK
######################

alias ban {
	if ([$0]) {
		^assign -him
		^assign him $0
		userhost $him -cmd ban2 $$0 $$3 $$4
	}	{mode $C +b}
}
alias ban2 {
	if ([$1]==[<UNKNOWN>]) {echo *** No such nickname} {ban3 $0 $1 $2}
}
alias ban3 {
	^assign -nic
	^assign -usr
	^assign -mach
	^assign -machine
	^assign nic $0
	^assign usr $strip(#~ $1)
	^assign mach $2
	^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$2]) 99 $2)]
	^assign machine *.$enleve($2)
	mode $C +b *!*$mid(0 8 $usr)*@$machine
}

############################################
#         SHOWS USERS ON A CHANNEL         #
# usage: /look    or   /count   to display #
# or : /look #channel   or /count #channel #
# who is or how many on channel            #
# by TG!cedras@rahul.net                   #
# This sucker is faster then older code :) #
############################################

alias repeat {
	@ rep.cnt = [$0]
	while ( rep.cnt > 0 )
	{
		$1-
		@rep.cnt = rep.cnt - 1
	}
	^assign -rep.cnt
}


alias look {
   @whoonc = [yes]
   @on_channel = C
   if ([$0]) 
     {
      @on_channel = [$0]
      } 
  whoon
  }

alias count {
   @on_channel = C
  if ([$0]) 
   {
    @on_channel = [$0]
    } 
  whoon
  }

alias whoon {
   ^assign -total
   ^assign -wholist
   ^assign -whonum
   @opernum = 0
   @ircopnum = 0
   @nochop = 0	
   ^on ^who "*Channel*" /comment
   ^on ^who "*End of* /comment
   ^on ^who "*" whocount $$1 $$2
   ^who $on_channel
   ^wait
   @total = [$#whonum]
   @nochop = total - opernum
   if ( whoonc == [yes] ) {show_look $wholist}
   echo #*#* ON Channel ${on_channel}
   echo #*#* [TOTAL : $total users] [$opernum Chops] [$nochop NotChops] [$ircopnum IrcOPs]
   ^on ^who -
   ^assign whoonc no
  }
alias whocount {
   if ([$1]==[G@]||[$1]==[H@]||[$1]==[G*@]||[$1]==[H*@]) {@opernum=opernum+1}
   if ([$1]==[G*]||[$1]==[H*]||[$1]==[G*@]||[$1]==[H*@]) {@ircopnum=ircopnum+1}
   ^assign -dash_fill
   @diff = 0
   ^assign -nicklength
   @chanstat = [$1]
   if ([$@chanstat]==[1]) {@nickad = [$chanstat\-\-]}
   if ([$@chanstat]==[2]) {@nickad = [$chanstat\-]}
   if ([$@chanstat]==[3]) {@nickad = [$chanstat]}
   @nick = [$0\-$nickad]
   @nicklength = [$@nick]
   @diff = 13 - nicklength
   repeat $diff @dash_fill = dash_fill ## [-]
   ^assign enclosed [$dash_fill$nick]
   @wholist = [$wholist $enclosed]
   @whonum = [$whonum $1]
  }

alias show_look {
  @wholist_size = [$#wholist]
  @wholist_counter = 0
  while (wholist_counter < wholist_size) {
    @ind_wholist =0
    ^assign -wholist_display
    while (ind_wholist < 4) {
      ^assign wholist_display $wholist_display $word($wholist_counter $wholist)
      @ind_wholist = ind_wholist + 1
      @wholist_counter = wholist_counter + 1
      }
    echo ---> $wholist_display
    }
}

############# END OF /LOOK  /COUNT  FUNCTIONS

###########################
#  IGNORING FUNCTION      #
#  BY TG!cedras@rahul.net #             
#  /ig /uig /sig /zig     #
###########################

alias shoo {
	userhost $, -cmd ^assign hostig $$3@$$4
	wait
	//ignore $hostig msg
	timer 60 //ignore $hostig -msg
	^assign -hostig
}

## IGNORING (/ig <nick> or <whatever>)

alias ig {
  if ([$0]) {
    ^assign -ignick
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_ig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      ^assign ignore_list $ignore_list $0
      #echo #*#*#  $ignick \( $ignick \) is been ignored !
      #//^ignore $ignick msgs walls wallops invites notices notes ctcps crap
      echo #### Ignoring $ignick, to unignore: /uig $ignick
      //^ignore $ignick all
      @igflag = 0
      }
     }{
       echo *** USAGE: To ignore someones hostname completely: /ig <nick> or <address>
       }
  }

alias do_ig {
  if ([$0]!=[<UNKNOWN>]) {add_iglist $0 $1}
  }

alias add_iglist {
  @igflag = 1

  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  ^assign ignore_list $ignore_list $igfinal
  echo ### Ignoring $ignick \($igfinal\), to un-ignore: /uig $igfinal
  //^ignore $igfinal all
  }

## UNIGNORING (/uig <nick> or <whatever>)

alias uig {
  if ([$0]) {
    ^assign -ignick
    ^assign -igfinal
    ^assign ignick $0
    @igflag=0
    userhost $ignick -cmd do_nig $$3 $$4
    wait
    if ([$igflag] == [0]) {
      @ignore_list = [$remove_word($0 $ignore_list)]
      echo ###  $ignick is no longer being ignored.
      //ignore $ignick none
      @igflag = 0
      }
    }{
      echo *** USAGE: To remove someone from ignorance list /uig <nick> or <address>
   }
 }

alias do_nig {
  if ([$0]!=[<UNKNOWN>]) {remove_iglist $0 $1}
}

alias remove_iglist {
  @igflag = 1
  ^assign -usr
  ^assign -machine
  ^assign usr $strip(~# $0)
  ^alias enleve @ FUNCTION_RETURN = [$MID($INDEX("." [$1]) 99 $1)]
  ^assign machine *.$enleve($1)
  @igfinal = [\*$usr@$machine]
  @ignore_list = [$remove_word($igfinal $ignore_list)]
  echo ###  $ignick \($igfinal\) is no longer being ignored!
  //ignore $igfinal none
  }

## SHOW IGNORE LIST (/sig)

alias sig echo ### List of people being ignored:;echo ->>   $ignore_list

## ZAP IGNORE LIST (/zig)

alias zig {
  @ind=0
  while ( word($ind $ignore_list-) ) {
    //ignore $word($ind $ignore_list) none
    @ind=ind+1
  }
  ^assign -ignore_list
  echo ### Ignorance list has been cleared!
  }

################# SPECIAL FUNCTIONS by Jeremy Nelson   hop!jnelson@iastate.edu
alias leftw {
    @ function_return = [$(1-$0)]
}
alias restw {
    @ function_return = [$(${[$0]+1}-)]
}
alias notw {
    if ([$0])
       {@ _pad = [ ]}
       {@ _pad = []}
    @ _words = [$1-]
    @ function_return = [$leftw($0 $1-)] ## [$_pad] ## [$restw(${[$0]+1} $1-)]
}

alias remove_word {
    @ _pattern = rmatch($0 $1-) - 1
    if (_pattern != -1)
       {@ function_return = notw($_pattern $1-)}
       {@ function_return = [$1-]}
}

################# END OF IGNORE FUNCTION

######################################
# SMART /CHAT INTERFACE              #
# BY TG!cedras@rahul.net             #
######################################
# to initiate a chat connection      #
# -> type: /chat <nickname>          #
# to close current connection and    #
# initiate another                   #
# -> type: /chat <new nickname>      #
# to connect to a chat request       #
# -> type: /chat                     #
# to close current connection and    #
# respond to a request               #
# -> type: /chat                     #
# to close a chat connection         #
# -> type: /chat                     #
#                                    #
# /autoquery on | off   to set auto  #
#                       query mode   #
######################################
## This is not really necessary, I personally prefer to do it manually by
## /dcc chat nickname then /msg =nickname blah blah (note =) (or hit tab).

########### SMART /CHAT INTERFACE

on ^ctcp "% % DCC CHAT % *" {
@chat_request = [$0]
}

alias chat {
if (![$chat_current] && ![$chat_request] && ![$0] ) {
echo #*#* No chat requests issued to you or nickname Specified
}{
  if (chat_current)
   {
    //dcc close chat $chat_current
    ^assign -chat_current
    if ([$auto_query] == [on]) {//query}
    }
  if ([$0])
   {
   //dcc chat $0
   @chat_current = [$0]
   if ([$auto_query] == [on]) {//query =$chat_current}
   ^assign -chat_request
    } {
      if (chat_request)
       {
       //dcc chat $chat_request
       @chat_current = chat_request
       if ([$auto_query] == [on]) {//query =$chat_current}
       ^assign -chat_request
        }
       }
    }
}

############### AUTO_QUERY SWITCH

# AUTOQUERY IS ON BY DEFAULT, CHANGE THE NEXT LINE IF YOU DONT
# WANT IT THAT WAY
^assign auto_query ON
####################


alias autoquery {
if ([$0]) {
  ^assign auto_query $0
  if ([$auto_query] == [on]) {
  ^assign auto_query ON
  echo #*#* Auto-Query has been set to  ON 
  } {
    ^assign auto_query OFF
    echo #*#* Auto-Query has been set to  OFF 
  } 
}{
echo #*#* Usage: /autoquery on | off   to set your auto-query mode
echo #*#*        Puts you automatically in query mode on a dcc chat if set to ON
echo ->>  Current Auto Query Status:  $auto_query 
 }
}

################## END OF /CHAT  FUNCTION

#########################################
#         IRC Answering Machine         #
#        by  TG!cedras@rahul.net        #       
#########################################
# This Script records all incoming      #
# Messages and Notices to you whether   #
# You are present or away               #
# *hysterical laughs*   Yes ! :-)       #
# We have indeed gone mad :)            #
#########################################
# How to Use:                           #
# /record     tells your machine status #
# /record ON  to set machine ON         #
# /record OFF to set machine OFF        #
# /play       to play back your msgs    #
# /erase      to erase messages         #
# /playmsg    to play back message file #
# /savemsg    to save messages to file  #
#####################################################################
## Known bug: message numbers are sorted alphabetically, so if you have 11
## messages they'll be played: 1, 10, 11, 2, 3,..., 8, and 9.  -Jolo

############### RECORD SWITCH

## Recorder will record any messages while you are away by default,
## change the next line if you dont want it that way .. 
^assign record_when_away YES

^assign record_status OFF

############ /RECORD

alias record {
if ([$0]) {
  ^assign record_status $0
  if ([$record_status] == [on]) {
  ^assign record_status ON
  start_answering_machine
  echo #*#* Answering Machine has been set to  ON 
  } {
    ^assign record_status OFF
     stop_answering_machine
    echo #*#* Answering Machine has been set to  OFF 
  } 
}{
echo #*#* Usage: /record on | off   Sets your answering machine to ON or OFF
echo #*#* Other: /play              Plays  back your messages
echo #*#*      : /erase   [#'s]     Erases messages         [none specified = all]
echo #*#*      : /savemsg [#'s]     Saves  messages to disk [none specified = all]
echo #*#*      : /playmsg           Plays  messages previously saved to disk
echo ->>  Current Answering Machine Status:  $record_status 
 }
}

@record_msg = 0

alias start_answering_machine {

#^on #^notice -294 * {
#^assign message_nick $0
#^assign message_addr $strip(#~ $userhost())
#@message_in = [$1-]
#@message_time = mid(4 15 $STIME($TIME()) )
#recordmessages
#}

^on #^msg -294 * {
^assign message_nick $0
^assign message_addr $strip(#~ $userhost())
@message_in = [$1-]
@message_time = mid(4 15 $STIME($TIME()) )
recordmessages
}

}

alias stop_answering_machine {
^on #^notice -294 -*
^on #^msg -294 -*
}

alias recordmessages {
@record_msg = record_msg + 1
^assign recordmsga.$record_msg $message_nick
^assign recordmsgb.$record_msg $message_addr
^assign recordmsgc.$record_msg $message_in
^assign recordmsgd.$record_msg $message_time
}

############ /PLAY

alias play {
^set hold_mode on
echo Hold mode is on!  Number of messages: $record_msg 
echo Message    Nick        Address                               Date/Time
echo -------    ----        -------                               ---------
foreach recordmsga rm {
echo $[3]{rm}        $[9]recordmsga[$rm]   $[35]recordmsgb[$rm]   $recordmsgd[$rm]
echo ->  $recordmsgc[$rm]
echo ------------------------------------------------------------------------------
     }
#^set hold_mode off
}

############ /ERASE

alias erase {
set hold_mode off
if ([$0]) {
  @ind=0
  while ( word($ind $0-) ) {
     if ([$(recordmsga.$word($ind $0-))]) {
        echo #*#* Erasing message # : $word($ind $0-)
        ^assign -recordmsga.${word($ind $0-)}
        ^assign -recordmsgb.${word($ind $0-)}
        ^assign -recordmsgc.${word($ind $0-)}
        ^assign -recordmsgd.${word($ind $0-)}
        } {
            if ([$0] == [\*]) {erase_all_messages} {
                  echo #*#* That message does not exist ! \($word($ind $0-)\)
             }
           }
    @ind=ind+1
     }
echo #*#* DONE !
  }{erase_all_messages}

}

alias erase_all_messages {
echo #*#* Erasing ALL your Messages.....
foreach recordmsga rm {
     ^assign -recordmsga[$rm]
     ^assign -recordmsgb[$rm]
     ^assign -recordmsgc[$rm]
     ^assign -recordmsgd[$rm]
     }
@record_msg = 0
echo #*#* DONE !
}

############ /AWAY

on ^idle 15 away_check
alias away_check {
   ^assign -away_status
    userhost $N -cmd ^assign away_status $$2
    wait
    if ([$away_status] == [\-]) {
    if ([$record_when_away] == [YES]) {
     //away 15-minute auto-away
    ^assign record_status ON
     start_answering_machine
      }
		{//away 15-minute auto-away}
    }
}

alias away {
if ([$0]) {
 if ([$record_when_away] == [YES]) {
 ^assign away_msg $0- : msgs are being saved
 //away $away_msg
 ^assign record_status ON
 start_answering_machine
 }{//away //away $0-}
} {//away;stop_answering_machine;^assign record_status OFF}
}

########################### END OF ANSWERING MACHINE !

##################################
# /PAUSE to put pause mode on    #
# /PAUSE to return to normal     #
# /UNPAUSE for the skepticals :p #
# TG!cedras@rahul.net            #
##################################
alias pause {
  if (!pauseset) {
    ^SET HOLD_MODE ON
    @pauseset = [ON]
    echo #*#* In Pause Mode... (hit Enter/Return to continue scrolling if paused)
    } {
       if ([$pauseset] == [ON]) {
         ^SET HOLD_MODE OFF
         ^assign -pauseset
         echo #*#* Back to normal scroll mode ... (Pause Mode cancelled)
         } {}
       }
}

alias unpause {
@pauseset = [ON]
pause
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*#* END OF SUPERPAK STUFF, FOLLOWING IS CUSTOM STUFF BY JOLO & FRIENDS #*#*
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* Sends /notice to every channel op on current channel
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
alias wall
{
  ^assign -tmp.wall.str
  @ tmp.wall.cnt = 0
  while (word($tmp.wall.cnt $chanusers($C)))
  {
    if (ischanop($word($tmp.wall.cnt $chanusers($C)) $C))
      {@ tmp.wall.str = tmp.wall.str##[,$word($tmp.wall.cnt $chanusers($C))]}
    @ tmp.wall.cnt = tmp.wall.cnt + 1
  }
  ^notice $mid(1 500 $tmp.wall.str) [$C Ops] $0-
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*           CTCP flood protection by Richard Hecker (garf@clo.com)
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* The author said: When I upgraded to 2.8.16, I realized that NO_CTCP_FLOOD
#* was completely broken, so I rewrote all CTCP handling in script...
#* Pro's:
#* - ignores all ctcp requests except: TIME, VERSION, PING, and ECHO
#* - does not respond to VERSIONs sent to a channel
#* - enforces a maximum of 1 CTCP reply sent out every 2 seconds.
#* Con's:
#* - breaks /IGNORE whatever CTCP ...But I've never been one to use /IGNORE...
#*     I just ignore stuff 'in my mind'
#* Minor mod by Jolo to re-enable USERINFO

alias ctcprep
{
  if ((lastctcprep + 2) <= time())
    {notice $0 $1-}
    {xecho -l crap *** CTCP reply aborted: $*}
  @ lastctcprep = time()
}

alias nuhton {@ function_return = left($Index(! $0) $0)}

:The main script:

## finger and clientinfo are disabled for your own protection

on ^raw_irc "% privmsg % :finger*" xecho -l crap *** CTCP FINGER from $0 to $2: $strip( $4-) (ignored)
on ^raw_irc "% privmsg % :clientinfo*" xecho -l crap *** CTCP CLIENTINFO from $0 to $2: $strip( $4-) (ignored)

#on ^raw_irc "% privmsg % :userinfo*" xecho -l crap *** CTCP USERINFO from $0 to $2: $strip( $4-) (ignored)
on ^raw_irc "% privmsg % :userinfo*" {
	if (rmatch($2 &* #*))
	{
		xecho -l crap *** CTCP USERINFO from $0 to $2 (ignored)
	}
	{
		xecho -l crap *** CTCP USERINFO from $0 to $2: $strip( $4-)
		ctcprep $nuhton($0) USERINFO $myuserinfo
	}
}

on ^raw_irc "% privmsg % :version*" {
	if (rmatch($2 &* #*))
	{
		xecho -l crap *** CTCP VERSION from $0 to $2: $strip( $4-) (ignored)
	}
	{
		xecho -l crap *** CTCP VERSION from $0 to $2: $strip( $4-)
		ctcprep $nuhton($0) VERSION $myversion: JoloPak $jp_version
	}
}

on ^raw_irc "% privmsg % :time*" {
	xecho -l crap *** CTCP TIME from $0 to $2: $strip( $4-)
	ctcprep $nuhton($0) TIME $stime($time())
}

on ^raw_irc "% privmsg % :ping*" {
	xecho -l crap *** CTCP PING from $0 to $2: $strip( $4-)
	ctcprep $nuhton($0) PING $strip( $4-)
}

on ^raw_irc "% privmsg % :echo*" {
	xecho -l crap *** CTCP ECHO from $0 to $2: $strip( $4-)
	ctcprep $nuhton($0) ECHO $strip( $4-)
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* Richard Hecker's hack to stay connected to an IRC server
#* Check every 5 minutes, if disconnected, connect to next server in list.
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
on #-timer 305 "*0" evnt.5min
on #-timer 305 "*5" evnt.5min

alias evnt.5min
{
	if (!myservers())
		{
		echo *** Reconnecting automatically at $stime($time())
		server +
		}
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* Ping myself every hour so it appears I am not idling.
#* This does not prevent getting disconnected by server timeouts.
#*    (to turn on by default, just delete the # before 'idlesafe')
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
ALIAS idlesafe //^ctcp $N ping;timer -refnum 555 3600 idlesafe
#idlesafe

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#* Nick Completer by DC-itsme (carabalo@hilbert.geom.umn.edu)
#* version 0.70 ALPHA (preliminary test version)
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

#### Jolo modified control keys to ^k and ^t, also deleted many comments
#### and bold echo statements for brevity and more consistent look.

### This script originally claims ^n and ^t .
### This is a fairly simple script to run.  Start typing the nick of someone
### on the channel to which you are currently speaking.  Then press Ctrl-k.
### This script fills in a nick for you.  If choices are given (i.e., if
### several nicks match the search string -- whatever you typed after the
### last space preceding your pressing Ctrl-k), press Ctrl-t to switch among
### these.  Typing a 2 or 3 letter search string will make using Ctrl-t
### unnecessary in most cases.
### Please direct all comments to the author.

//^bind ^k parse_command complete_the_nick
//^bind ^t parse_command change_nicks

### deletes $0 chars from the end of the input line
//alias delchars {
      @ delchars_ctr = 0
      //while ([$delchars_ctr]<[$0]) {
         //parsekey backspace;@ delchars_ctr = delchars_ctr + 1 }
      //^assign -delchars_ctr
}

//alias get_search {
      //^assign nic.search.temp [$~]
      @ nic.search.len = [$@nic.search.temp] - 2
      @ nic.search = [$mid(1 $nic.search.len [$~])]
      //^assign -nic.search.temp
}

//alias complete_the_nick {
   //parsekey erase_line;//parsekey yank_from_cutbuffer

   @ nic.toggle=0
   //^assign -thenick;//^assign -nic.list
   //^assign -nic.search;//^assign -nic.search.len

### Get search string.
   if ([$right(1 $U)]== [ ]) {
      @ nic.search = [$right(0 [])]
      }{
      get_search $U
   }

### Now print the first match and THEN create a list of all nicks in $C
### starting with nic.search .
    ^assign -nic.chanusers
    @ nic.chanusers = [$chanusers($C)]

### The next line won't work right without the ^\^^ in front of nic.chanusers.
   @ nic.search2 = [${nic.search##[*]}]
   @ listnum = [$match($^\^^nic.search2 $^\^^nic.chanusers)]
   @ thenick = [$word(${listnum - 1} $nic.chanusers)]
   @ nic.ctr1 = [$listnum] 
   //^assign -listnum;//^assign -nic.search2
   delchars $nic.search.len
   //type $^\^^thenick
   @ nic.toggle = 1;@nic.ctr2 = 0
   @ nic.list = [$thenick]
   //while ([$nic.ctr1] <= [$#nic.chanusers]) {
      if (  match($^\^^nic.search* $word($nic.ctr1 $^\^^nic.chanusers)) > 0 ) {
         @ nic.list = [$nic.list $word($nic.ctr1 $nic.chanusers)]
      }{}
      @ nic.ctr1 = nic.ctr1 + 1
   }
   if ([$#nic.list] > 1) {
      echo Press Ctrl-t to switch among the nicks in []'s:  [$nic.list]
      }{
      if ([$#nic.list] < 1) {
         eval echo *** Nick Completer did not find a nick beginning with '$^\^^nic.search' on channel ${ C }.
         }{}
   }
}

//alias change_nicks {
   if (nic.toggle) {
      if (nic.ctr2 < [$#nic.list] - 1) {
         @ nic.ctr2 = nic.ctr2 + 1
      }{ @ nic.ctr2 = 0}
      delchars $@thenick
      @ thenick = [$word($nic.ctr2 $nic.list)]
      //type $^\^^{ thenick }
      //^assign -nic.chanusers
   }{}
}

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
#*     J O L O P A K   H E L P       *#  
#*#*#**##*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#

alias jhelp {
if ([$0]) {
if ([$0]==[1]) {jhelp1} 
if ([$0]==[2]) {jhelp2} 
if ([$0]==[3]) {jhelp3} 
if ([$0]==[4]) {jhelp4} 
if ([$0]==[5]) {jhelp5} 
if ([$0]==[6]) {jhelp6} 
}{main_help}
}

alias main_help {
//clear
echo +-----------------------------------------------------------------+
echo |                   JOLOPAK MAIN HELP SCREEN                      |
echo +-----------------------------------------------------------------+
echo | The following are available by typing the appropriate command:  |
echo | /jhelp 1    Commands Screen 1: Basic chatting                   |
echo | /jhelp 2    Commands Screen 2: Channel maintenance              |
echo | /jhelp 3    Commands Screen 3: Investigating & ignoring People  |
echo | /jhelp 4    Commands Screen 4: Answering machine & DCC chat     |
echo | /jhelp 5    Commands Screen 5: Miscellaneous commands           |
echo | /jhelp 6    Commands Screen 6: Keyboard shortcuts               |
echo |                                                                 |
echo | Required arguments are shown, optional ones are in [brackets].  |
echo | ***  General IRC help on WWW at  http://www.irchelp.org/  ****  |
echo +-----------------------------------------------------------------+
}

alias jhelp1 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 1: Basic chatting                     |
echo +-----------------------------------------------------------------+
echo | /j #channel          join a channel or follow an invite         |
echo | /n [#channel]        list names of people on irc or channel     |
echo | /part [#channel]     part a channel or to part current one      |
echo | /w nick              see someone's information and channels     |
echo | /idle nick           check how long someone has been idle       |
echo | /p nick/#channel     ping a person or channel to test lag       |
echo | /m nick              send a private message to someone          |
echo +-----------------------------------------------------------------+
}

alias jhelp2 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 2: Channel maintenance                |
echo +-----------------------------------------------------------------+
echo | /look [#channel]      show who is on channel with statistics    |
echo | /count [#channel]     show channel statistics                   |
echo | /t [topic]            set topic or to view it if none supplied  |
echo | /wall message         private message to current channel ops    |
echo | /idle nick            find out how long someone has been idle   |
echo | /chop nick1 nick2...  grant channel ops to up to 4 people       |
echo | /deop nick1 nick2...  remove channel ops from up to 4 people    |
echo | /k nick [comment]     kick someone out of the channel           |
echo | /ban [nick]           ban someone, w/o nick shows channel bans  |
echo | /kb nick              kick & ban someone out of a channel       |
echo | /ub user@hostmask     unban user@hostmask e.g. from /ban        |
echo +-----------------------------------------------------------------+
}

alias jhelp3 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 3: Investigating & Ignoring People    |
echo +-----------------------------------------------------------------+
echo | /f nick                 ctcp finger someone                     |
echo | /finger nick/host       unix finger nick/host, /finger for help |
echo | /v nick                 find out someone's irc client version   |
echo |                                                                 |
echo | /shoo                   temporarily ignore last to /msg you     |
echo | ctrl-o                  ignore last person to /msg you          |
echo | /ig nick or user@host   ignore the specified person             |
echo | /uig nick or user@host  unignore somebody                       |
echo | /sig                    show list of people being ignored       |
echo | /zig                    zap (delete) ignore list                |
echo +-----------------------------------------------------------------+
}

alias jhelp4 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 4: Answering Machine & DCC Chat       |
echo +-----------------------------------------------------------------+
echo | /away message     mark yourself as away, turns on ans. machine  |
echo | /away             mark yourself as back, turns off ans. machine |
echo | /record [on|off]  check machine status or turn on|off           |
echo | /play             play back your messages                       |
echo | /erase            erase your messages                           |
echo |                                                                 |
echo | /chat             to accept a chat request, or close current    |
echo |                   request and respond to another, or just close |
echo | /chat nickname    to send a chat request, or close current      |
echo |                   connection and open new one to specified nick |
echo +-----------------------------------------------------------------+
}

alias jhelp5 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 5: Miscellaneous Commands             |
echo +-----------------------------------------------------------------+
echo | /pause              toggle pause mode on|off, e.g. for /list    |
echo | /h+ or /h-          another way to turn pause on (+) or off (-) |
echo | /list *keyword*     search for channels containing keyword      |
echo | /slap nick          slap action, use *very* sparingly           |
echo | /dns host           find out the ip address of a host           |
echo | /autorejoin on|off  to set autorejoin status to ON or OFF       |
echo | /reload             reloads your .ircrc script                  |
echo +-----------------------------------------------------------------+
}

alias jhelp6 {
//clear
echo +-----------------------------------------------------------------+
echo |           Commands Screen 6: Keyboard Shortcuts                 |
echo +-----------------------------------------------------------------+
echo | escape-p    scroll to previous screen (up), also contrl-p       |
echo | escape-n    scroll to next screen (down)                        |
echo | escape-e    scroll to end                                       |
echo | contrl-n    toggle to next channel if you're on more than 1     |
echo | tab         switch through nicks you messaged recently          |
echo | up arrow    go up through list of previous lines typed          |
echo | down arrow  go down through list of previous lines typed        |
echo | contrl-k    complete nick (type 1st few letters then ctrl-k)    |
echo | contrl-t    cycle through list of completed nicks if >1 matches |
echo +-----------------------------------------------------------------+
}

######################### END OF JOLOPAK HELP ##############################

## These affect your control key bindings
## I put these at the end to avoid conflicts with other stuff above

#### Remap your arrow keys: up/down = scroll through previous lines you typed,
#### left/right moves your cursor on the current line.
BIND META1-O META2
BIND META1-[ META2
BIND META2-A BACKWARD_HISTORY
BIND META2-B FORWARD_HISTORY
BIND META2-C FORWARD_CHARACTER
BIND META2-D BACKWARD_CHARACTER
#### Ctrl-b before & after text to make it bold
BIND ^B SELF_INSERT
#### Ctrl-n to switch between channels
BIND ^N SWITCH_CHANNELS
#### Ctrl-p to scroll to previous screen(s) - same as Esc-p
BIND ^P SCROLL_BACKWARDS
#### I don't recommend it, but if you use /window, Ctrl-w to toggle
BIND ^W NEXT_WINDOW
#### Ctrl-v before & after text to make it inverse
BIND ^V SELF_INSERT
#### Ctrl-z to escape to shell ("fg" in a few mins to return to IRC)
BIND ^Z STOP_IRC
#### Ctrl-_ (shift-hyphen) before & after text to underline
BIND ^_ SELF_INSERT
#### Ctrl-o ignores the last person who sent you a message
BIND ^O parse_command ig $,

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
#*   FINAL INSTRUCTIONS
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*

eval echo * JoloPak $jp_version loaded *
## The following makes you "invisible" so you don't get flooded or spammed,
## but friends won't find you either unless they know your exact nick.
eval //mode $N +i

SET DISPLAY ON
